<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>¿Quién Quiere Ser Millonario?</title>
    <link rel="stylesheet" href="shared.css" />
    <style>
      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(
          135deg,
          #0f0f0f 0%,
          #1a1a2e 50%,
          #16213e 100%
        );
        color: white;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .container {
        width: 90%;
        max-width: 800px;
        text-align: center;
      }

      /* Pantalla de bienvenida */
      .welcome-screen {
        display: block;
      }

      .welcome-screen h1 {
        font-size: 3rem;
        margin-bottom: 30px;
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .name-input {
        margin: 30px 0;
      }

      .name-input input {
        padding: 15px 20px;
        font-size: 1.2rem;
        border: 2px solid #ffd700;
        border-radius: 25px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        text-align: center;
        min-width: 300px;
      }

      .name-input input::placeholder {
        color: rgba(255, 255, 255, 0.7);
      }

      .start-btn {
        padding: 15px 40px;
        font-size: 1.2rem;
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        color: #000;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        font-weight: bold;
        transition: transform 0.3s ease;
      }

      .start-btn:hover {
        transform: scale(1.05);
      }

      /* Pantalla del juego */
      .game-screen {
        display: none;
      }

      .player-info {
        margin-bottom: 30px;
        font-size: 1.3rem;
      }

      .player-name {
        color: #ffd700;
        font-weight: bold;
      }

      .question-container {
        background: rgba(0, 0, 0, 0.7);
        border: 3px solid #ffd700;
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      }

      .question-number {
        font-size: 1.1rem;
        color: #ffd700;
        margin-bottom: 15px;
      }

      .question-text {
        font-size: 1.4rem;
        margin-bottom: 30px;
        line-height: 1.4;
      }

      .options-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        max-width: 600px;
        margin: 0 auto;
      }

      .option {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border: 2px solid #4a4a4a;
        border-radius: 15px;
        padding: 15px 20px;
        font-size: 1rem;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: left;
        display: flex;
        align-items: center;
      }

      .option:hover {
        border-color: #ffd700;
        background: linear-gradient(135deg, #2a2a3e 0%, #26334e 100%);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2);
      }

      .option.selected {
        border-color: #ffd700;
        background: linear-gradient(135deg, #ffd700, #ffed4e);
        color: #000;
      }

      .option.correct {
        border-color: #4caf50;
        background: linear-gradient(135deg, #4caf50, #45a049);
        color: white;
        animation: pulse-correct 2s infinite;
      }

      .option.incorrect {
        border-color: #f44336;
        background: linear-gradient(135deg, #f44336, #d32f2f);
        color: white;
      }

      .option.eliminated {
        opacity: 0.3;
        pointer-events: none;
        background: rgba(100, 100, 100, 0.2) !important;
        border-color: #666 !important;
      }

      .option-letter {
        background: #ffd700;
        color: #000;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 15px;
        flex-shrink: 0;
      }

      .lifelines {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 30px;
      }

      .lifeline {
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid #666;
        border-radius: 10px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .lifeline:hover {
        border-color: #ffd700;
        background: rgba(255, 215, 0, 0.1);
      }

      .lifeline.used {
        opacity: 0.3;
        cursor: not-allowed;
        background: rgba(100, 100, 100, 0.2);
        border-color: #666;
      }

      .score-display {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #ffd700;
        border-radius: 10px;
        padding: 15px;
        color: #ffd700;
        font-weight: bold;
      }

      .next-btn {
        background: linear-gradient(45deg, #4caf50, #66bb6a, #4caf50);
        background-size: 200% 200%;
        color: white;
        border: none;
        border-radius: 20px;
        padding: 18px 40px;
        font-size: 1.2rem;
        font-weight: bold;
        cursor: pointer;
        margin: 25px;
        transition: all 0.4s ease;
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        text-transform: uppercase;
        letter-spacing: 1px;
        position: relative;
        overflow: hidden;
        animation: pulseGreen 2s infinite;
        opacity: 1;
        transform: translateY(0);
      }

      .next-btn:hover {
        transform: scale(1.08) translateY(-2px);
        box-shadow: 0 6px 25px rgba(76, 175, 80, 0.5);
        background-position: 100% 0;
      }

      .next-btn:active {
        transform: scale(1.02) translateY(0);
      }

      .next-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .next-btn:hover::before {
        left: 100%;
      }

      .next-btn[disabled] {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
        animation: none;
      }

      @keyframes pulseGreen {
        0%,
        100% {
          box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }
        50% {
          box-shadow: 0 4px 25px rgba(76, 175, 80, 0.6);
        }
      }

      .game-over {
        text-align: center;
        padding: 40px;
        background: rgba(0, 0, 0, 0.8);
        border: 3px solid #ffd700;
        border-radius: 20px;
        margin: 20px 0;
      }

      .final-score {
        font-size: 2rem;
        color: #ffd700;
        margin: 20px 0;
        font-weight: bold;
      }

      .play-again-btn {
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        color: #000;
        border: none;
        border-radius: 15px;
        padding: 15px 30px;
        font-size: 1.1rem;
        font-weight: bold;
        cursor: pointer;
        margin: 10px;
        transition: transform 0.3s ease;
      }

      .play-again-btn:hover {
        transform: scale(1.05);
      }

      @keyframes pulse-correct {
        0%,
        100% {
          box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
        }
        50% {
          box-shadow: 0 0 20px rgba(76, 175, 80, 0.7);
        }
      }

      @media (max-width: 768px) {
        .container {
          width: 95%;
        }
        .welcome-screen h1 {
          font-size: 2rem;
        }
        .options-container {
          grid-template-columns: 1fr;
        }
        .score-display {
          position: relative;
          top: auto;
          right: auto;
          margin: 20px auto;
        }
        .name-input input {
          min-width: 250px;
        }
      }

      /* Modal para pregunta al público */
      .audience-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .audience-modal.show {
        display: flex;
      }

      .audience-content {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border: 3px solid #ffd700;
        border-radius: 20px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
      }

      .audience-title {
        text-align: center;
        color: #ffd700;
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 20px;
      }

      .result-item {
        display: flex;
        align-items: center;
        margin: 15px 0;
        font-size: 1.1rem;
      }

      .result-letter {
        background: #ffd700;
        color: #000;
        width: 35px;
        height: 35px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 15px;
        flex-shrink: 0;
      }

      .result-bar-container {
        flex: 1;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        height: 25px;
        margin-right: 15px;
        overflow: hidden;
        position: relative;
      }

      .result-bar {
        height: 100%;
        background: linear-gradient(90deg, #ffd700 0%, #ffed4e 100%);
        width: 0%;
        transition: width 1.5s ease-in-out;
        border-radius: 10px;
      }

      .result-percentage {
        color: #ffd700;
        font-weight: bold;
        min-width: 50px;
        text-align: right;
      }

      .close-audience-btn {
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        color: #000;
        border: none;
        border-radius: 15px;
        padding: 12px 30px;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        display: block;
        margin: 20px auto 0;
        transition: transform 0.3s ease;
      }

      .close-audience-btn:hover {
        transform: scale(1.05);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Pantalla de bienvenida -->
      <div class="welcome-screen" id="welcomeScreen">
        <h1>¿Quién Quiere Ser Millonario?</h1>
        <div class="name-input">
          <input
            type="text"
            id="playerName"
            placeholder="Ingresa tu nombre"
            maxlength="20"
          />
        </div>
        <button class="start-btn" onclick="startGame()">
          ¡Comenzar Juego!
        </button>
      </div>

      <!-- Pantalla del juego -->
      <div class="game-screen" id="gameScreen">
        <div class="score-display">
          Pregunta: <span id="currentQuestionNum">1</span>/8<br />
          Premio: $<span id="currentPrize">1,000</span>
        </div>

        <div class="player-info">
          ¡Bienvenido/a,
          <span class="player-name" id="playerNameDisplay"></span>!
        </div>

        <div class="question-container">
          <div class="question-number">
            Pregunta <span id="questionNumber">1</span> de 8
          </div>
          <div class="question-text" id="questionText">
            Cargando pregunta...
          </div>

          <div class="options-container" id="optionsContainer">
            <!-- Las opciones se cargarán dinámicamente -->
          </div>
        </div>

        <div class="lifelines">
          <div
            class="lifeline"
            onclick="useFiftyFifty()"
            id="fiftyFiftyLifeline"
          >
            🔄 50:50
          </div>
          <div
            class="lifeline"
            onclick="useAudiencePoll()"
            id="audienceLifeline"
          >
            👥 Pregunta al Público
          </div>
        </div>

        <button
          class="next-btn"
          id="nextBtn"
          onclick="nextQuestion()"
          style="display: none"
        >
          <span id="nextBtnText">Siguiente Pregunta</span>
          <span id="nextBtnIcon"> ➤</span>
        </button>
      </div>

      <!-- Pantalla de game over -->
      <div class="game-over" id="gameOverScreen" style="display: none">
        <h2 id="gameOverTitle">¡Juego Terminado!</h2>
        <div class="final-score" id="finalScore">$0</div>
        <p id="gameOverMessage">¡Gracias por jugar!</p>
        <button class="play-again-btn" onclick="restartGame()">
          Jugar de Nuevo
        </button>
      </div>
    </div>

    <!-- Modal para pregunta al público -->
    <div class="audience-modal" id="audienceModal">
      <div class="audience-content">
        <div class="audience-title">👥 Pregunta al Público</div>
        <p style="text-align: center; margin-bottom: 20px; color: #ccc">
          Resultados de la votación del público:
        </p>
        <div class="audience-results" id="audienceResults">
          <!-- Los resultados se generarán dinámicamente -->
        </div>
        <button class="close-audience-btn" onclick="closeAudienceModal()">
          Cerrar
        </button>
      </div>
    </div>

    <script>
      // Estado del juego simplificado
      let gameState = {
        playerName: "",
        currentQuestionIndex: 0,
        questions: [],
        selectedOption: null,
        score: 1000,
        lifelinesUsed: {
          fiftyFifty: false,
          audience: false,
        },
        sessionId: null, // ID de sesión en el servidor
        isSpectator: false, // Modo espectador cuando pierdes
        gameActive: false, // Si la partida está activa (controlada por admin)
      };

      // Premios por pregunta
      const prizes = [1000, 2000, 5000, 10000, 25000, 50000, 100000, 1000000];

      // Iniciar el juego
      async function startGame() {
        const playerName = document.getElementById("playerName").value.trim();
        if (!playerName) {
          alert("Por favor ingresa tu nombre");
          return;
        }

        // Verificar si el juego está activo
        try {
          const gameStateResponse = await fetch("/api/game/state");
          if (gameStateResponse.ok) {
            const gameStateData = await gameStateResponse.json();
            if (!gameStateData.data.gameState.isActive) {
              const startBtn = document.querySelector(".start-btn");
              startBtn.textContent =
                "Esperando que el admin inicie la partida...";
              startBtn.disabled = true;
              startBtn.style.opacity = "0.6";

              alert(
                "El juego no está activo. Espera a que el administrador inicie la partida."
              );
              return;
            }
          }
        } catch (err) {
          console.error("Error verificando estado del juego:", err);
        }

        gameState.playerName = playerName;
        // Guardar nombre para no pedirlo de nuevo
        localStorage.setItem("playerName", playerName);

        // Crear sesión en backend
        const sessionRes = await fetch("/api/sessions", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ playerName }),
        });
        if (!sessionRes.ok) {
          console.error("Error creando sesión", sessionRes.status);
          alert(
            "No se pudo iniciar sesión. Por favor recarga y prueba de nuevo."
          );
          return;
        }
        const sessionData = await sessionRes.json();
        console.log("Respuesta del servidor:", sessionData);

        // La respuesta viene envuelta en APIResponse.Data
        if (
          sessionData.success &&
          sessionData.data &&
          sessionData.data.session
        ) {
          gameState.sessionId = sessionData.data.session.id;
          gameState.gameStarted = true;

          // Guardar sessionId en localStorage para persistencia
          localStorage.setItem("sessionId", gameState.sessionId);

          // Guardar estado completo
          saveGameState();
        } else {
          console.error("Formato de respuesta inválido:", sessionData);
          alert("Error en formato de respuesta del servidor.");
          return;
        }

        // Cargar preguntas
        await loadQuestions();

        // Mostrar pantalla del juego
        document.getElementById("welcomeScreen").style.display = "none";
        document.getElementById("gameScreen").style.display = "block";
        document.getElementById("playerNameDisplay").textContent = playerName;

        // Cargar primera pregunta
        loadCurrentQuestion();

        // Guardar estado después de cargar la primera pregunta
        saveGameState();
      }

      // Cargar preguntas desde la API
      async function loadQuestions() {
        try {
          const response = await fetch("/api/questions");
          if (!response.ok) {
            throw new Error("Error cargando preguntas");
          }
          const data = await response.json();
          gameState.questions = data.questions || [];
          console.log(`✅ ${gameState.questions.length} preguntas cargadas`);
        } catch (error) {
          console.error("❌ Error cargando preguntas:", error);
          alert("Error cargando preguntas. Por favor recarga la página.");
        }
      }

      // Cargar pregunta actual
      function loadCurrentQuestion() {
        console.log("📋 EJECUTANDO loadCurrentQuestion()");
        console.log(
          `   - currentQuestionIndex: ${gameState.currentQuestionIndex}`
        );
        console.log(
          `   - questions.length: ${gameState.questions?.length || 0}`
        );

        // Guardar tiempo de inicio de la pregunta para medir respuesta
        gameState.questionStartTime = Date.now();

        // Verificar si tenemos preguntas cargadas
        if (!gameState.questions || gameState.questions.length === 0) {
          console.log("❌ No hay preguntas cargadas, intentando cargar...");
          showWaitingMessage("Cargando preguntas...");
          loadQuestions().then(() => {
            console.log(
              "✅ Preguntas cargadas, reintentando loadCurrentQuestion"
            );
            loadCurrentQuestion();
          });
          return;
        }

        if (gameState.currentQuestionIndex >= gameState.questions.length) {
          console.log("🏆 Jugador completó todas las preguntas");
          endGame(true); // Ganó el juego
          return;
        }

        const question = gameState.questions[gameState.currentQuestionIndex];
        const questionNum = gameState.currentQuestionIndex + 1;

        console.log(
          `📝 Cargando pregunta ${questionNum}: ${question.question}`
        );

        // Actualizar UI
        document.getElementById("questionNumber").textContent = questionNum;
        document.getElementById("currentQuestionNum").textContent = questionNum;
        document.getElementById("currentPrize").textContent =
          prizes[gameState.currentQuestionIndex].toLocaleString();
        document.getElementById("questionText").textContent = question.question;

        // Limpiar selección previa
        gameState.selectedOption = null;

        // Ocultar mensaje de espera
        hideWaitingMessage();

        // Cargar opciones
        loadOptions(question.options);

        // Ocultar botón siguiente
        document.getElementById("nextBtn").style.display = "none";

        console.log("✅ Pregunta cargada exitosamente");
      }

      // Cargar opciones de la pregunta
      function loadOptions(options) {
        const container = document.getElementById("optionsContainer");
        container.innerHTML = "";

        Object.keys(options).forEach((letter) => {
          const option = document.createElement("div");
          option.className = "option";
          option.setAttribute("data-option", letter);
          option.style.pointerEvents = "auto"; // Habilitar interacción
          option.onclick = () => selectOption(letter);

          option.innerHTML = `
            <div class="option-letter">${letter}</div>
            <div>${options[letter]}</div>
          `;

          container.appendChild(option);
        });
      }

      // Seleccionar opción
      function selectOption(letter) {
        if (gameState.selectedOption) return; // Ya seleccionó

        gameState.selectedOption = letter;
        const question = gameState.questions[gameState.currentQuestionIndex];

        // Marcar opción seleccionada
        const selectedElement = document.querySelector(
          `[data-option="${letter}"]`
        );
        selectedElement.classList.add("selected");

        // Enviar respuesta al backend inmediatamente
        const timeToAnswer = Math.round(
          (Date.now() - gameState.questionStartTime) / 1000
        );
        fetch(`/api/sessions/${gameState.sessionId}/answer`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            questionId: question.id,
            selectedOption: gameState.selectedOption,
            timeToAnswer: timeToAnswer,
          }),
        })
          .then((res) => {
            if (!res.ok) throw new Error(`HTTP error ${res.status}`);
            return res.json();
          })
          .then((data) => console.log("Respuesta enviada al servidor", data))
          .catch((err) => console.error("Error enviando respuesta", err));

        // Deshabilitar todas las opciones para evitar cambios
        document.querySelectorAll(".option").forEach((option) => {
          option.style.pointerEvents = "none";
        });

        // Mostrar mensaje de espera
        showWaitingMessage(
          "Esperando al administrador para revelar la respuesta..."
        );
      }

      // Revelar la respuesta correcta
      function revealAnswer(correctAnswer, wasCorrect) {
        console.log(
          `🎯 EJECUTANDO revealAnswer - correctAnswer: ${correctAnswer}, wasCorrect: ${wasCorrect}`
        );

        // Ocultar mensaje de espera
        hideWaitingMessage();

        // Obtener todas las opciones
        const allOptions = document.querySelectorAll(".option");
        console.log(`🎛️ Opciones encontradas en DOM: ${allOptions.length}`);

        allOptions.forEach((option, index) => {
          const letter = option.getAttribute("data-option");
          console.log(`📍 Opción ${index}: letra=${letter}, elemento=`, option);
        });

        // Marcar respuesta correcta
        const correctElement = document.querySelector(
          `[data-option="${correctAnswer}"]`
        );

        console.log(
          `🔍 Buscando elemento con data-option="${correctAnswer}":`,
          correctElement
        );

        if (correctElement) {
          console.log("✅ Elemento encontrado, aplicando clase 'correct'");
          correctElement.classList.add("correct");

          // Forzar repaint del navegador
          correctElement.offsetHeight;

          console.log(
            `✅ Clases después de agregar 'correct':`,
            correctElement.classList.toString()
          );
        } else {
          console.log(
            `❌ No se encontró elemento para la opción correcta: ${correctAnswer}`
          );

          // Debugging adicional
          console.log("🔍 Todos los elementos con data-option:");
          document.querySelectorAll("[data-option]").forEach((el) => {
            console.log(
              `   - data-option="${el.getAttribute("data-option")}"`,
              el
            );
          });
        }

        // Si la respuesta fue incorrecta, marcar como tal
        if (!wasCorrect && gameState.selectedOption) {
          console.log(
            `❌ Marcando respuesta incorrecta: ${gameState.selectedOption}`
          );
          const incorrectElement = document.querySelector(
            `[data-option="${gameState.selectedOption}"]`
          );
          if (incorrectElement) {
            incorrectElement.classList.add("incorrect");
            console.log(
              `❌ Marcada opción incorrecta: ${gameState.selectedOption}`
            );
          }
        }

        // Deshabilitar todas las opciones
        console.log("🔒 Deshabilitando todas las opciones");
        document.querySelectorAll(".option").forEach((option) => {
          option.style.pointerEvents = "none";
        });

        // Mostrar resultado después de 3 segundos
        setTimeout(() => {
          if (wasCorrect) {
            console.log("🎉 Respuesta correcta - avanzando pregunta");
            if (
              gameState.currentQuestionIndex ===
              gameState.questions.length - 1
            ) {
              // Última pregunta - ganó el juego
              endGame(true);
            } else {
              // Esperar comando del admin para siguiente pregunta
              showWaitingMessage(
                "Esperando al administrador para continuar..."
              );

              // Guardar estado después de respuesta correcta
              saveGameState();
            }
          } else {
            // Perdió - modo espectador
            gameState.isSpectator = true;
            showSpectatorMode();

            // Guardar estado en modo espectador
            saveGameState();
          }
        }, 3000);
      }

      // Terminar juego
      function endGame(won) {
        const gameOverScreen = document.getElementById("gameOverScreen");
        const gameScreen = document.getElementById("gameScreen");
        const title = document.getElementById("gameOverTitle");
        const score = document.getElementById("finalScore");
        const message = document.getElementById("gameOverMessage");

        gameScreen.style.display = "none";
        gameOverScreen.style.display = "block";

        if (won) {
          title.textContent = "¡FELICIDADES! ¡GANASTE!";
          score.textContent = `$${prizes[prizes.length - 1].toLocaleString()}`;
          message.textContent = "¡Eres el nuevo millonario!";
        } else {
          title.textContent = "¡Juego Terminado!";
          score.textContent = `$${gameState.score.toLocaleString()}`;
          message.textContent = "No te preocupes, ¡puedes intentarlo de nuevo!";
        }
        
        // Nota: No limpiamos localStorage aquí porque puede ser que el jugador 
        // haya perdido individualmente, no que la partida haya terminado globalmente
      }

      // Terminar juego por decisión del administrador
      function endGameByAdmin() {
        const gameOverScreen = document.getElementById("gameOverScreen");
        const gameScreen = document.getElementById("gameScreen");
        const welcomeScreen = document.getElementById("welcomeScreen");
        const title = document.getElementById("gameOverTitle");
        const score = document.getElementById("finalScore");
        const message = document.getElementById("gameOverMessage");

        // Ocultar todas las pantallas
        gameScreen.style.display = "none";
        welcomeScreen.style.display = "none";
        gameOverScreen.style.display = "block";

        title.textContent = "🔴 Partida Terminada";
        score.textContent = `$${gameState.score.toLocaleString()}`;
        message.textContent = "El administrador ha terminado la partida. Todos los datos han sido limpiados.";
        
        // Limpiar todos los datos persistentes
        clearAllGameData();
      }

      // Función para limpiar todos los datos del juego
      function clearAllGameData() {
        console.log("🧹 Limpiando todos los datos del juego...");
        
        // Limpiar localStorage
        localStorage.removeItem("sessionId");
        localStorage.removeItem("gameState");
        localStorage.removeItem("currentQuestion");
        localStorage.removeItem("playerAnswers");
        
        // Resetear estado del juego
        gameState = {
          playerName: localStorage.getItem("playerName") || "", // Mantener solo el nombre para comodidad
          currentQuestionIndex: 0,
          questions: [],
          selectedOption: null,
          score: 1000,
          lifelinesUsed: {
            fiftyFifty: false,
            audience: false,
          },
          sessionId: null,
          isSpectator: false,
          gameActive: false,
        };
        
        console.log("✅ Datos del juego limpiados completamente");
      }

      // Reiniciar juego
      function restartGame() {
        // Limpiar datos completamente antes de reiniciar
        clearAllGameData();
        
        // Mostrar pantalla de bienvenida
        document.getElementById("gameOverScreen").style.display = "none";
        document.getElementById("welcomeScreen").style.display = "block";
        document.getElementById("gameScreen").style.display = "none";
        
        // Limpiar formulario (excepto el nombre si ya estaba guardado)
        const nameInput = document.getElementById("playerNameInput");
        const savedName = localStorage.getItem("playerName");
        if (savedName) {
          nameInput.value = savedName;
        }

        // Resetear comodines
        document.getElementById("fiftyFiftyLifeline").classList.remove("used");
        document.getElementById("audienceLifeline").classList.remove("used");

        // Limpiar mensajes especiales
        const waitingMsg = document.getElementById("waitingMessage");
        const spectatorMsg = document.getElementById("spectatorMode");
        if (waitingMsg) waitingMsg.remove();
        if (spectatorMsg) spectatorMsg.remove();
      }

      // Comodín 50:50
      function useFiftyFifty() {
        if (gameState.lifelinesUsed.fiftyFifty || gameState.selectedOption)
          return;

        gameState.lifelinesUsed.fiftyFifty = true;
        document.getElementById("fiftyFiftyLifeline").classList.add("used");

        // Enviar al backend
        if (gameState.sessionId) {
          fetch(`/api/sessions/${gameState.sessionId}/lifeline`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ type: "fiftyFifty" }),
          })
            .then((res) => {
              if (!res.ok) throw new Error(`HTTP error ${res.status}`);
              return res.json();
            })
            .then((data) =>
              console.log("Comodín 50:50 enviado al servidor", data)
            )
            .catch((err) => console.error("Error enviando comodín 50:50", err));
        }

        const question = gameState.questions[gameState.currentQuestionIndex];
        const correctAnswer = question.correctAnswer;
        const options = Object.keys(question.options);
        const incorrectOptions = options.filter((opt) => opt !== correctAnswer);

        // Eliminar 2 opciones incorrectas aleatoriamente
        const toEliminate = incorrectOptions
          .sort(() => 0.5 - Math.random())
          .slice(0, 2);

        toEliminate.forEach((option) => {
          const element = document.querySelector(`[data-option="${option}"]`);
          element.classList.add("eliminated");
        });
      }

      // Comodín pregunta al público
      function useAudiencePoll() {
        if (gameState.lifelinesUsed.audience || gameState.selectedOption)
          return;

        gameState.lifelinesUsed.audience = true;
        document.getElementById("audienceLifeline").classList.add("used");

        // Enviar al backend
        if (gameState.sessionId) {
          fetch(`/api/sessions/${gameState.sessionId}/lifeline`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ type: "audience" }),
          })
            .then((res) => {
              if (!res.ok) throw new Error(`HTTP error ${res.status}`);
              return res.json();
            })
            .then((data) =>
              console.log(
                "Comodín pregunta al público enviado al servidor",
                data
              )
            )
            .catch((err) =>
              console.error("Error enviando comodín pregunta al público", err)
            );
        }

        const question = gameState.questions[gameState.currentQuestionIndex];
        const correctAnswer = question.correctAnswer;

        // Generar porcentajes simulados (favoreciendo la respuesta correcta)
        const percentages = generateAudiencePercentages(correctAnswer);

        // Mostrar modal
        showAudienceResults(percentages);
      }

      // Generar porcentajes para pregunta al público
      function generateAudiencePercentages(correctAnswer) {
        const options = ["A", "B", "C", "D"];
        const percentages = {};

        // La respuesta correcta tendrá entre 40-70%
        const correctPercent = Math.floor(Math.random() * 30) + 40;
        percentages[correctAnswer] = correctPercent;

        // Distribuir el resto
        const remaining = 100 - correctPercent;
        const otherOptions = options.filter((opt) => opt !== correctAnswer);

        let remainingPercent = remaining;
        otherOptions.forEach((option, index) => {
          if (index === otherOptions.length - 1) {
            percentages[option] = remainingPercent;
          } else {
            const percent = Math.floor(
              Math.random() *
                (remainingPercent - (otherOptions.length - index - 1))
            );
            percentages[option] = percent;
            remainingPercent -= percent;
          }
        });

        return percentages;
      }

      // Mostrar resultados de pregunta al público
      function showAudienceResults(percentages) {
        const modal = document.getElementById("audienceModal");
        const resultsContainer = document.getElementById("audienceResults");

        resultsContainer.innerHTML = "";

        Object.keys(percentages).forEach((option) => {
          const resultItem = document.createElement("div");
          resultItem.className = "result-item";
          resultItem.innerHTML = `
            <div class="result-letter">${option}</div>
            <div class="result-bar-container">
              <div class="result-bar" style="width: ${percentages[option]}%"></div>
            </div>
            <div class="result-percentage">${percentages[option]}%</div>
          `;
          resultsContainer.appendChild(resultItem);
        });

        modal.classList.add("show");
      }

      // Cerrar modal de pregunta al público
      function closeAudienceModal() {
        document.getElementById("audienceModal").classList.remove("show");
      }

      // Permitir Enter para enviar nombre
      document
        .getElementById("playerName")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            startGame();
          }
        });

      // Autocompletar nombre y comenzar si ya existe
      document.addEventListener("DOMContentLoaded", async () => {
        const savedPlayerName = localStorage.getItem("playerName");
        const nameInput = document.getElementById("playerName");

        if (savedPlayerName && nameInput) {
          nameInput.value = savedPlayerName;

          // Verificar si el juego está activo antes de iniciar automáticamente
          try {
            const response = await fetch("/api/game/state");
            if (response.ok) {
              const gameStateData = await response.json();
              if (gameStateData.data.gameState.isActive) {
                console.log(`👋 Bienvenido de vuelta, ${savedPlayerName}!`);

                // Iniciar automáticamente si ya tenemos el nombre
                await validateOrCreateSession(savedPlayerName);
              } else {
                // Si el juego no está activo, mostrar mensaje de espera
                const startBtn = document.querySelector(".start-btn");
                if (startBtn) {
                  startBtn.textContent = `Esperando partida... (${savedPlayerName})`;
                  startBtn.disabled = true;
                  startBtn.style.opacity = "0.6";
                }
                console.log(
                  "⏳ Juego no activo, esperando al administrador..."
                );
              }
            }
          } catch (err) {
            console.error("Error verificando estado del juego:", err);
            // Si hay error, permitir que el usuario intente manualmente
            const startBtn = document.querySelector(".start-btn");
            if (startBtn) {
              startBtn.textContent = `Jugar como ${savedPlayerName}`;
            }
          }
        } else {
          // No hay nombre guardado, usuario debe ingresar uno
          console.log("👤 Nuevo jugador, ingresa tu nombre");
        }

        // Conectar WebSocket independientemente
        connectWebSocket();

        // Verificar periódicamente si el juego se activa
        setInterval(async () => {
          if (
            savedPlayerName &&
            document.getElementById("welcomeScreen").style.display !== "none"
          ) {
            try {
              const response = await fetch("/api/game/state");
              if (response.ok) {
                const gameStateData = await response.json();
                if (gameStateData.data.gameState.isActive) {
                  const startBtn = document.querySelector(".start-btn");
                  if (startBtn && startBtn.disabled) {
                    startBtn.textContent = `Jugar como ${savedPlayerName}`;
                    startBtn.disabled = false;
                    startBtn.style.opacity = "1";
                    console.log("🎮 ¡Juego activado! Puedes unirte ahora.");
                  }
                }
              }
            } catch (err) {
              // Silenciar errores de verificación periódica
            }
          }
        }, 5000); // Verificar cada 5 segundos
      });

      // Validar o crear sesión al recargar la página
      async function validateOrCreateSession(playerName) {
        try {
          // Primero verificar si tengo una sesión guardada
          const savedSessionId = localStorage.getItem("sessionId");

          if (savedSessionId) {
            // Verificar si la sesión sigue activa en el servidor
            const sessionResponse = await fetch(
              `/api/sessions/${savedSessionId}`
            );
            if (sessionResponse.ok) {
              const sessionData = await sessionResponse.json();

              // Restaurar estado completo desde el servidor
              gameState.sessionId = savedSessionId;
              gameState.playerName = playerName;

              // Guardar el nombre en localStorage para futuras sesiones
              localStorage.setItem("playerName", playerName);

              console.log(
                `🔄 Restaurando sesión: ${sessionData.data.session.gameStatus}`
              );

              // Cargar preguntas primero
              await loadQuestions();

              // Configurar según el estado del jugador
              if (sessionData.data.session.gameStatus === "eliminated") {
                // El jugador ya perdió - modo espectador
                gameState.isSpectator = true;
                gameState.gameStarted = true;
                gameState.currentQuestionIndex =
                  sessionData.data.session.currentQuestion - 1;
                gameState.score = sessionData.data.session.totalPrize || 0;

                // Ir a la pantalla de juego en modo espectador
                document.getElementById("welcomeScreen").style.display = "none";
                document.getElementById("gameScreen").style.display = "block";

                // Cargar la pregunta actual para espectadores
                loadCurrentQuestionForSpectator();
                showSpectatorMode();
                showWaitingMessage("Has perdido. Estás en modo espectador.");

                console.log(
                  `🍿 Sesión restaurada en modo espectador - Pregunta ${
                    gameState.currentQuestionIndex + 1
                  }`
                );
                return;
              } else if (sessionData.data.session.gameStatus === "active") {
                // Sesión activa, restaurar posición exacta
                gameState.currentQuestionIndex =
                  sessionData.data.session.currentQuestion - 1;
                gameState.score = sessionData.data.session.totalPrize || 0;
                gameState.gameStarted = true;

                // Ir directamente al juego y cargar la pregunta actual
                document.getElementById("welcomeScreen").style.display = "none";
                document.getElementById("gameScreen").style.display = "block";

                // Restaurar los comodines usados
                if (sessionData.data.session.lifelinesUsed) {
                  gameState.lifelinesUsed = {
                    fiftyFifty:
                      sessionData.data.session.lifelinesUsed.fiftyFifty ||
                      false,
                    audience:
                      sessionData.data.session.lifelinesUsed.audience || false,
                    phone:
                      sessionData.data.session.lifelinesUsed.phone || false,
                  };

                  // Marcar comodines como usados en la UI
                  if (gameState.lifelinesUsed.fiftyFifty) {
                    const fiftyElement =
                      document.getElementById("fiftyFiftyLifeline");
                    if (fiftyElement) fiftyElement.classList.add("used");
                  }
                  if (gameState.lifelinesUsed.audience) {
                    const audienceElement =
                      document.getElementById("audienceLifeline");
                    if (audienceElement) audienceElement.classList.add("used");
                  }
                  if (gameState.lifelinesUsed.phone) {
                    const phoneElement =
                      document.getElementById("phoneLifeline");
                    if (phoneElement) phoneElement.classList.add("used");
                  }
                }

                // Cargar la pregunta actual
                loadCurrentQuestion();

                console.log(
                  `🎮 Sesión activa restaurada - Pregunta ${
                    gameState.currentQuestionIndex + 1
                  }, Score: ${gameState.score}`
                );
                return;
              }
            } else {
              // Sesión no válida, limpiar localStorage
              localStorage.removeItem("sessionId");
              console.log("🧹 Sesión anterior no válida, limpiando...");
            }
          }

          // No hay sesión válida, crear nueva
          await startGame();
        } catch (error) {
          console.error("Error validando sesión:", error);
          // En caso de error, iniciar juego normalmente
          await startGame();
        }
      }

      // WebSocket para recibir comandos del admin
      function connectWebSocket() {
        const ws = new WebSocket(`ws://${window.location.host}/ws`);

        ws.onopen = () => {
          console.log("✅ WebSocket conectado");
        };

        ws.onmessage = (event) => {
          try {
            const message = JSON.parse(event.data);
            console.log("📨 Comando del admin:", message);

            if (message.type === "nextQuestion") {
              console.log("🔄 Procesando comando nextQuestion");
              console.log(`   - isSpectator: ${gameState.isSpectator}`);
              console.log(
                `   - questions loaded: ${gameState.questions?.length || 0}`
              );
              console.log(
                `   - currentQuestionIndex: ${gameState.currentQuestionIndex}`
              );

              // Llamar nextQuestion sin condiciones restrictivas - el admin controla cuándo avanzar
              nextQuestion();
            } else if (message.type === "revealAnswer") {
              revealAnswerCommand();
            } else if (message.type === "gameEnded") {
              // La partida ha sido terminada por el administrador
              console.log("🔴 Partida terminada por el administrador");
              console.log("🧹 Limpiando todos los datos...");
              
              // Terminar el juego para este jugador
              endGameByAdmin();
              
              // Mostrar notificación si es posible
              if (typeof showNotification === 'function') {
                showNotification("🔴 La partida ha sido terminada por el administrador");
              }
            } else if (message.type === "gameState") {
              gameState.gameActive = message.data.isActive;
              if (!gameState.gameActive && !message.data.gameEndedByAdmin) {
                // La partida ha terminado normalmente - restablecer todos los jugadores
                resetPlayerToInitialState();
                showGameNotActive();
              } else if (gameState.gameActive) {
                // El juego se activó, habilitar botón de inicio
                const startBtn = document.querySelector(".start-btn");
                if (startBtn) {
                  startBtn.textContent = "¡Comenzar Juego!";
                  startBtn.disabled = false;
                  startBtn.style.opacity = "1";
                }
              }
            }
          } catch (err) {
            console.error("Error procesando comando WebSocket:", err);
          }
        };

        ws.onclose = () => {
          console.log("🔌 WebSocket desconectado, reintentando en 3s...");
          setTimeout(connectWebSocket, 3000);
        };

        ws.onerror = (err) => {
          console.error("❌ Error WebSocket:", err);
        };
      }

      // Siguiente pregunta (controlada por admin)
      function nextQuestion() {
        console.log("🔄 EJECUTANDO nextQuestion()");
        console.log(
          `   - Estado inicial: isSpectator=${gameState.isSpectator}, currentQuestionIndex=${gameState.currentQuestionIndex}`
        );
        console.log(
          `   - Preguntas disponibles: ${gameState.questions?.length || 0}`
        );

        // Si no tenemos preguntas cargadas, cargarlas primero
        if (!gameState.questions || gameState.questions.length === 0) {
          console.log("📥 No hay preguntas, cargando...");
          loadQuestions().then(() => {
            console.log("✅ Preguntas cargadas, reintentando nextQuestion");
            nextQuestion();
          });
          return;
        }

        if (gameState.isSpectator) {
          // Los espectadores solo ven la pregunta pero no pueden interactuar
          console.log("🍿 Avanzando pregunta para espectador");
          gameState.currentQuestionIndex++;
          loadCurrentQuestionForSpectator();
          hideWaitingMessage();

          // Guardar estado del espectador
          saveGameState();
          return;
        }

        // Jugadores activos
        console.log("🎮 Avanzando pregunta para jugador activo");
        gameState.currentQuestionIndex++;

        // Actualizar puntuación basada en la pregunta anterior
        if (gameState.currentQuestionIndex > 0) {
          gameState.score = prizes[gameState.currentQuestionIndex - 1];
        }

        gameState.selectedOption = null; // Reset selection
        gameState.questionStartTime = Date.now(); // Reset timer

        console.log(
          `   - Nueva pregunta: ${gameState.currentQuestionIndex + 1}`
        );
        console.log(`   - Nueva puntuación: ${gameState.score}`);

        loadCurrentQuestion();
        hideWaitingMessage();

        // Guardar estado después de avanzar pregunta
        saveGameState();
      }

      // Cargar pregunta actual para espectadores (solo lectura)
      function loadCurrentQuestionForSpectator() {
        if (gameState.currentQuestionIndex >= gameState.questions.length) {
          showWaitingMessage(
            "El juego ha terminado. Esperando al administrador..."
          );
          return;
        }

        const question = gameState.questions[gameState.currentQuestionIndex];
        const questionNum = gameState.currentQuestionIndex + 1;

        // Actualizar UI
        document.getElementById("questionNumber").textContent = questionNum;
        document.getElementById("currentQuestionNum").textContent = questionNum;
        document.getElementById("currentPrize").textContent =
          prizes[gameState.currentQuestionIndex].toLocaleString();
        document.getElementById("questionText").textContent = question.question;

        // Cargar opciones en modo solo lectura
        loadOptionsForSpectator(question.options);

        // Ocultar botón siguiente
        document.getElementById("nextBtn").style.display = "none";

        // Mostrar mensaje de espectador si no existe
        if (!document.getElementById("spectatorMode")) {
          showSpectatorMode();
        }
      }

      // Cargar opciones para espectadores (sin interacción)
      function loadOptionsForSpectator(options) {
        const container = document.getElementById("optionsContainer");
        container.innerHTML = "";

        Object.keys(options).forEach((letter) => {
          const option = document.createElement("div");
          option.className = "option";
          option.style.pointerEvents = "none"; // No clickeable
          option.style.opacity = "0.7"; // Menos visible
          option.innerHTML = `
            <span class="option-letter">${letter}</span>
            <span class="option-text">${options[letter]}</span>
          `;
          container.appendChild(option);
        });
      }

      // Mostrar mensaje de espera
      function showWaitingMessage(message) {
        const waitingDiv = document.createElement("div");
        waitingDiv.id = "waitingMessage";
        waitingDiv.style.cssText = `
          text-align: center;
          margin: 20px;
          padding: 20px;
          background: var(--gold-light);
          border: 2px solid var(--gold-primary);
          border-radius: 15px;
          color: var(--gold-dark);
          font-weight: bold;
          font-size: 1.2rem;
        `;
        waitingDiv.textContent = message;

        const container = document.querySelector(".question-container");
        container.appendChild(waitingDiv);
      }

      // Ocultar mensaje de espera
      function hideWaitingMessage() {
        const waitingDiv = document.getElementById("waitingMessage");
        if (waitingDiv) {
          waitingDiv.remove();
        }
      }

      // Restablecer jugador al estado inicial cuando termina la partida
      function resetPlayerToInitialState() {
        console.log("🔄 Restableciendo jugador al estado inicial...");

        // Reset del estado del juego
        gameState = {
          playerName: gameState.playerName || "", // Mantener el nombre
          sessionId: gameState.sessionId || null, // Mantener sessionId si existe
          currentQuestionIndex: 0,
          score: 0,
          questions: [],
          selectedOption: null,
          gameActive: false,
          questionStartTime: null,
          lifelines: {
            fiftyFifty: true,
            audiencePoll: true,
          },
          isSpectator: false, // Quitar modo espectador
          gameStarted: false,
        };

        // Remover elemento de modo espectador si existe
        const spectatorMode = document.getElementById("spectatorMode");
        if (spectatorMode) {
          spectatorMode.remove();
        }

        // Ocultar mensaje de espera
        hideWaitingMessage();

        // Mostrar pantalla de bienvenida
        document.getElementById("welcomeScreen").style.display = "flex";
        document.getElementById("gameScreen").style.display = "none";
        document.getElementById("gameOverScreen").style.display = "none";

        // Restablecer el input del nombre si el jugador no tiene nombre
        if (!gameState.playerName) {
          document.getElementById("playerName").value = "";
        }

        // Restablecer botón de inicio
        const startBtn = document.querySelector(".start-btn");
        if (startBtn && gameState.playerName) {
          startBtn.textContent = "¡Esperar Nueva Partida!";
          startBtn.disabled = true;
          startBtn.style.opacity = "0.6";
        }

        // Limpiar localStorage de estado de partida (mantener nombre)
        const savedName = localStorage.getItem("playerName");
        localStorage.removeItem("gameState");
        localStorage.removeItem("sessionId"); // Limpiar también sessionId
        if (savedName) {
          localStorage.setItem("playerName", savedName);
        }

        console.log("✅ Jugador restablecido al estado inicial");
      }

      // Modo espectador
      function showSpectatorMode() {
        // Verificar si ya existe el mensaje de espectador
        const existingSpectator = document.getElementById("spectatorMode");
        if (existingSpectator) {
          return; // Ya está en modo espectador
        }

        const spectatorDiv = document.createElement("div");
        spectatorDiv.id = "spectatorMode";
        spectatorDiv.style.cssText = `
          text-align: center;
          margin: 20px;
          padding: 30px;
          background: rgba(244, 67, 54, 0.1);
          border: 2px solid #f44336;
          border-radius: 15px;
          color: #f44336;
          position: relative;
          z-index: 100;
        `;
        spectatorDiv.innerHTML = `
          <h3>🍿 Modo Espectador</h3>
          <p>Has perdido, pero puedes seguir viendo el juego.</p>
          <p>Espera a que el administrador termine la partida para jugar de nuevo.</p>
        `;

        const container = document.querySelector(".question-container");
        if (container) {
          // Insertar al principio del contenedor
          container.insertBefore(spectatorDiv, container.firstChild);
        }

        // Deshabilitar comodines para espectadores
        const lifelines = document.querySelectorAll(".lifeline");
        lifelines.forEach((lifeline) => {
          lifeline.style.pointerEvents = "none";
          lifeline.style.opacity = "0.5";
        });
      }

      // Comando revelar respuesta del admin
      async function revealAnswerCommand() {
        console.log("🎯 INICIANDO revealAnswerCommand");
        console.log("Estado actual del juego:", gameState);

        try {
          // Si estamos en modo espectador o no tenemos las preguntas cargadas,
          // intentar cargar la pregunta actual del servidor
          if (
            gameState.isSpectator ||
            !gameState.questions ||
            gameState.questions.length === 0
          ) {
            console.log("📥 Cargando preguntas desde servidor...");
            await loadQuestions();
          }

          console.log(
            "📊 Preguntas disponibles:",
            gameState.questions?.length || 0
          );
          console.log(
            "📍 Índice de pregunta actual:",
            gameState.currentQuestionIndex
          );

          // Verificar si tenemos una pregunta válida
          if (gameState.currentQuestionIndex < gameState.questions.length) {
            const question =
              gameState.questions[gameState.currentQuestionIndex];
            console.log("❓ Pregunta actual:", question);

            const wasCorrect =
              gameState.selectedOption === question.correctAnswer;

            console.log(
              `🔍 Revelando respuesta: ${question.correctAnswer}, fue correcta: ${wasCorrect}`
            );
            console.log(
              "🎯 Opción seleccionada por usuario:",
              gameState.selectedOption
            );

            // Llamar a la función revealAnswer con los parámetros correctos
            revealAnswer(question.correctAnswer, wasCorrect);
          } else {
            console.log("❌ No hay pregunta válida para revelar la respuesta");
            console.log("🔧 Intentando fallback...");

            // Como fallback, obtener la respuesta desde las opciones visibles
            const options = document.querySelectorAll(".option");
            console.log("🎛️ Opciones encontradas:", options.length);

            if (options.length > 0) {
              // Intentar obtener la pregunta actual desde el servidor
              try {
                const response = await fetch("/api/questions");
                const questionsData = await response.json();
                console.log(
                  "📦 Datos de preguntas del servidor:",
                  questionsData
                );

                if (
                  questionsData.questions &&
                  questionsData.questions.length > 0
                ) {
                  // Usar la primera pregunta como fallback
                  const fallbackQuestion = questionsData.questions[0];
                  console.log("🔄 Usando pregunta fallback:", fallbackQuestion);

                  const wasCorrect =
                    gameState.selectedOption === fallbackQuestion.correctAnswer;
                  revealAnswer(fallbackQuestion.correctAnswer, wasCorrect);
                } else {
                  // Fallback final
                  console.log(
                    "⚠️ Usando fallback final con respuesta hardcodeada"
                  );
                  revealAnswer("D", false);
                }
              } catch (fetchError) {
                console.error("Error obteniendo preguntas:", fetchError);
                // Fallback final
                revealAnswer("D", false);
              }
            }
          }
        } catch (error) {
          console.error("Error en revealAnswerCommand:", error);
        }
      }

      // Mostrar que el juego no está activo
      function showGameNotActive() {
        document.getElementById("gameScreen").style.display = "none";
        document.getElementById("gameOverScreen").style.display = "none";
        document.getElementById("welcomeScreen").style.display = "flex";

        const nameInput = document.getElementById("playerName");
        if (gameState.playerName && nameInput) {
          nameInput.value = gameState.playerName;
        }

        const startBtn = document.querySelector(".start-btn");
        if (startBtn) {
          startBtn.textContent = "Esperando que el admin inicie la partida...";
          startBtn.disabled = true;
          startBtn.style.opacity = "0.6";
        }

        // Mostrar mensaje temporal de que la partida terminó
        showTemporaryMessage(
          "🎮 La partida ha terminado. Todos los jugadores han sido restablecidos.",
          "info"
        );
      }

      // Mostrar mensaje temporal
      function showTemporaryMessage(message, type = "info") {
        const messageDiv = document.createElement("div");
        messageDiv.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: ${type === "info" ? "#2196f3" : "#4caf50"};
          color: white;
          padding: 15px 30px;
          border-radius: 10px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          z-index: 1000;
          font-weight: bold;
          text-align: center;
          max-width: 400px;
        `;
        messageDiv.textContent = message;
        document.body.appendChild(messageDiv);

        // Remover después de 5 segundos
        setTimeout(() => {
          if (messageDiv.parentNode) {
            messageDiv.remove();
          }
        }, 5000);
      }

      // Sincronizar estado completo con el servidor
      async function syncStateWithServer() {
        if (!gameState.sessionId) {
          console.log("🚫 No hay sessionId para sincronizar");
          return false;
        }

        try {
          const response = await fetch(`/api/sessions/${gameState.sessionId}`);
          if (!response.ok) {
            console.log(
              "❌ Error obteniendo estado del servidor:",
              response.status
            );
            return false;
          }

          const sessionData = await response.json();
          if (!sessionData.success) {
            console.log("❌ Respuesta del servidor no exitosa:", sessionData);
            return false;
          }

          const serverSession = sessionData.data.session;

          // Actualizar estado local con datos del servidor
          gameState.currentQuestionIndex =
            (serverSession.currentQuestion || 1) - 1;
          gameState.score = serverSession.totalPrize || 0;

          // Actualizar estado del jugador
          if (serverSession.gameStatus === "eliminated") {
            gameState.isSpectator = true;
          } else if (serverSession.gameStatus === "active") {
            gameState.isSpectator = false;
          }

          // Sincronizar comodines
          if (serverSession.lifelinesUsed) {
            gameState.lifelinesUsed = {
              fiftyFifty: serverSession.lifelinesUsed.fiftyFifty || false,
              audience: serverSession.lifelinesUsed.audience || false,
              phone: serverSession.lifelinesUsed.phone || false,
            };
          }

          console.log(
            `🔄 Estado sincronizado - Pregunta: ${
              gameState.currentQuestionIndex + 1
            }, Score: ${gameState.score}, Estado: ${serverSession.gameStatus}`
          );
          return true;
        } catch (error) {
          console.error("Error sincronizando con servidor:", error);
          return false;
        }
      }

      // Guardar estado completo en localStorage
      function saveGameState() {
        const stateToSave = {
          playerName: gameState.playerName,
          sessionId: gameState.sessionId,
          currentQuestionIndex: gameState.currentQuestionIndex,
          score: gameState.score,
          isSpectator: gameState.isSpectator,
          gameStarted: gameState.gameStarted,
          lifelinesUsed: gameState.lifelinesUsed,
          timestamp: Date.now(),
        };

        localStorage.setItem("gameState", JSON.stringify(stateToSave));
        console.log("💾 Estado del juego guardado en localStorage");
      }

      // Cargar estado completo desde localStorage
      function loadGameState() {
        try {
          const savedState = localStorage.getItem("gameState");
          if (savedState) {
            const parsedState = JSON.parse(savedState);

            // Verificar que no sea muy antiguo (más de 24 horas)
            const now = Date.now();
            const savedTime = parsedState.timestamp || 0;
            const twentyFourHours = 24 * 60 * 60 * 1000;

            if (now - savedTime > twentyFourHours) {
              console.log("🗑️ Estado guardado muy antiguo, descartando...");
              localStorage.removeItem("gameState");
              return null;
            }

            console.log("📱 Estado del juego cargado desde localStorage");
            return parsedState;
          }
        } catch (error) {
          console.error("Error cargando estado guardado:", error);
          localStorage.removeItem("gameState");
        }
        return null;
      }
    </script>
  </body>
</html>
