<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>¬øQui√©n Quiere Ser Millonario?</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(
          135deg,
          #0f0f0f 0%,
          #1a1a2e 50%,
          #16213e 100%
        );
        color: white;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .container {
        width: 90%;
        max-width: 800px;
        text-align: center;
      }

      /* Pantalla de bienvenida */
      .welcome-screen {
        display: block;
      }

      .welcome-screen h1 {
        font-size: 2.5rem;
        margin-bottom: 30px;
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .name-input {
        margin-bottom: 30px;
      }

      .name-input input {
        padding: 15px 20px;
        font-size: 1.2rem;
        border: 2px solid #ffd700;
        border-radius: 25px;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        text-align: center;
        min-width: 300px;
      }

      .name-input input::placeholder {
        color: rgba(255, 255, 255, 0.7);
      }

      .start-btn {
        padding: 15px 40px;
        font-size: 1.2rem;
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        color: #000;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        font-weight: bold;
        transition: transform 0.3s ease;
      }

      .start-btn:hover {
        transform: scale(1.05);
      }

      /* Pantalla del juego */
      .game-screen {
        display: none;
      }

      /* Pantalla de espera */
      .waiting-screen {
        display: none;
      }

      .waiting-message {
        font-size: 1.8rem;
        margin-bottom: 30px;
        color: #ffd700;
        text-align: center;
        font-weight: bold;
      }

      .animated-text {
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 0.7;
          transform: scale(1);
        }
        50% {
          opacity: 1;
          transform: scale(1.05);
        }
      }

      .loading-dots {
        display: inline-block;
        animation: loadingDots 1.5s infinite;
      }

      @keyframes loadingDots {
        0%,
        20% {
          content: "";
        }
        40% {
          content: ".";
        }
        60% {
          content: "..";
        }
        80%,
        100% {
          content: "...";
        }
      }

      .loading-dots::after {
        content: "";
        animation: loadingDots 1.5s infinite;
      }

      .presenter-icon {
        font-size: 4rem;
        margin: 20px 0;
        animation: bounce 2s ease-in-out infinite;
      }

      @keyframes bounce {
        0%,
        20%,
        50%,
        80%,
        100% {
          transform: translateY(0);
        }
        40% {
          transform: translateY(-20px);
        }
        60% {
          transform: translateY(-10px);
        }
      }

      .player-info {
        margin-bottom: 30px;
        font-size: 1.3rem;
      }

      .player-name {
        color: #ffd700;
        font-weight: bold;
      }

      .question-container {
        background: rgba(0, 0, 0, 0.7);
        border: 3px solid #ffd700;
        border-radius: 20px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
      }

      .question-number {
        font-size: 1.1rem;
        color: #ffd700;
        margin-bottom: 15px;
      }

      .question-text {
        font-size: 1.4rem;
        margin-bottom: 30px;
        line-height: 1.4;
      }

      .options-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        max-width: 600px;
        margin: 0 auto;
      }

      .option {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border: 2px solid #4a4a4a;
        border-radius: 15px;
        padding: 15px 20px;
        font-size: 1rem;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
        text-align: left;
        display: flex;
        align-items: center;
      }

      .option:hover {
        border-color: #ffd700;
        background: linear-gradient(135deg, #2a2a3e 0%, #26334e 100%);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(255, 215, 0, 0.2);
      }

      .option-letter {
        background: #ffd700;
        color: #000;
        width: 30px;
        height: 30px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 15px;
        flex-shrink: 0;
      }

      .lifelines {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 30px;
      }

      .lifeline {
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid #666;
        border-radius: 10px;
        color: white;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .lifeline:hover {
        border-color: #ffd700;
        background: rgba(255, 215, 0, 0.1);
      }

      .lifeline.used {
        opacity: 0.3;
        cursor: not-allowed;
        background: rgba(100, 100, 100, 0.2);
        border-color: #666;
      }

      .lifeline.used:hover {
        border-color: #666;
        background: rgba(100, 100, 100, 0.2);
      }

      .option.eliminated {
        opacity: 0.3;
        pointer-events: none;
        background: rgba(100, 100, 100, 0.2) !important;
        border-color: #666 !important;
        animation: fadeOut 0.8s ease-in-out;
      }

      .option.eliminated .option-letter {
        background: #666;
        color: #333;
      }

      @keyframes fadeOut {
        0% {
          opacity: 1;
          transform: scale(1);
        }
        50% {
          transform: scale(0.9);
        }
        100% {
          opacity: 0.3;
          transform: scale(1);
        }
      }

      @keyframes highlight {
        0%,
        100% {
          box-shadow: 0 0 5px rgba(255, 215, 0, 0.3);
        }
        50% {
          box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }
      }

      /* Modal para pregunta al p√∫blico */
      .audience-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }

      .audience-modal.show {
        display: flex;
      }

      .audience-content {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border: 3px solid #ffd700;
        border-radius: 20px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
        animation: modalSlideIn 0.5s ease-out;
      }

      @keyframes modalSlideIn {
        from {
          transform: translateY(-50px);
          opacity: 0;
        }
        to {
          transform: translateY(0);
          opacity: 1;
        }
      }

      .audience-title {
        text-align: center;
        color: #ffd700;
        font-size: 1.5rem;
        font-weight: bold;
        margin-bottom: 20px;
      }

      .audience-results {
        margin: 20px 0;
      }

      .result-item {
        display: flex;
        align-items: center;
        margin: 15px 0;
        font-size: 1.1rem;
      }

      .result-letter {
        background: #ffd700;
        color: #000;
        width: 35px;
        height: 35px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 15px;
        flex-shrink: 0;
      }

      .result-bar-container {
        flex: 1;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        height: 25px;
        margin-right: 15px;
        overflow: hidden;
        position: relative;
      }

      .result-bar {
        height: 100%;
        background: linear-gradient(90deg, #ffd700 0%, #ffed4e 100%);
        width: 0%;
        transition: width 1.5s ease-in-out;
        border-radius: 10px;
      }

      .result-percentage {
        color: #ffd700;
        font-weight: bold;
        min-width: 50px;
        text-align: right;
      }

      .close-audience-btn {
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        color: #000;
        border: none;
        border-radius: 15px;
        padding: 12px 30px;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        display: block;
        margin: 20px auto 0;
        transition: transform 0.3s ease;
      }

      .close-audience-btn:hover {
        transform: scale(1.05);
      }

      .prize-ladder {
        position: fixed;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #ffd700;
        border-radius: 10px;
        padding: 20px;
        max-height: 80vh;
        overflow-y: auto;
      }

      .prize-item {
        padding: 5px 10px;
        margin: 2px 0;
        border-radius: 5px;
        font-size: 0.9rem;
        transition: all 0.3s ease;
      }

      .prize-item.current {
        background: #ffd700;
        color: #000;
        font-weight: bold;
        animation: prize-pulse 2s infinite;
      }

      .prize-item.won {
        background: rgba(0, 255, 0, 0.2);
        color: #00ff00;
        border: 1px solid #00ff00;
      }

      @keyframes prize-pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.05);
        }
      }

      /* Tabla de jugadores */
      .players-table {
        position: fixed;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #ffd700;
        border-radius: 10px;
        padding: 20px;
        max-height: 80vh;
        overflow-y: auto;
        min-width: 200px;
      }

      .players-title {
        text-align: center;
        color: #ffd700;
        font-size: 1.1rem;
        font-weight: bold;
        margin-bottom: 15px;
        border-bottom: 1px solid #ffd700;
        padding-bottom: 10px;
      }

      .player-item {
        display: flex;
        align-items: center;
        padding: 10px 15px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        transition: all 0.3s ease;
      }

      .player-item:hover {
        background: rgba(255, 215, 0, 0.1);
        transform: translateX(5px);
      }

      .player-item.current-player {
        background: linear-gradient(
          135deg,
          rgba(255, 215, 0, 0.2) 0%,
          rgba(255, 215, 0, 0.1) 100%
        );
        border-left: 4px solid #ffd700;
        font-weight: bold;
      }

      .player-item.current-player .player-name-item {
        color: #ffd700;
      }
      .player-item.current-player {
        background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
        color: #000;
        font-weight: bold;
        border-color: #ffd700;
      }

      .player-avatar {
        width: 30px;
        height: 30px;
        border-radius: 50%;
        background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        margin-right: 10px;
        flex-shrink: 0;
        color: white;
        font-size: 0.9rem;
      }

      .player-item.current-player .player-avatar {
        background: linear-gradient(135deg, #000 0%, #333 100%);
        color: #ffd700;
      }

      .player-info-item {
        flex: 1;
      }

      .player-name-item {
        font-size: 0.9rem;
        margin-bottom: 2px;
      }

      .player-amount {
        font-size: 0.8rem;
        color: #ccc;
      }

      .player-item.current-player .player-amount {
        color: #000;
      }

      @media (max-width: 768px) {
        .container {
          width: 95%;
        }

        .welcome-screen h1 {
          font-size: 2rem;
        }

        .options-container {
          grid-template-columns: 1fr;
        }

        .prize-ladder {
          display: none;
        }

        .players-table {
          display: none;
        }

        .name-input input {
          min-width: 250px;
        }
      }

      /* Di√°logos animados */
      .dialog-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
      }

      .dialog-overlay.show {
        opacity: 1;
        visibility: visible;
      }

      .dialog-box {
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border: 3px solid #ffd700;
        border-radius: 20px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
        text-align: center;
        transform: scale(0.7) translateY(-50px);
        transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      }

      .dialog-overlay.show .dialog-box {
        transform: scale(1) translateY(0);
      }

      .dialog-icon {
        font-size: 3rem;
        margin-bottom: 20px;
        display: block;
      }

      .dialog-title {
        font-size: 1.5rem;
        color: #ffd700;
        margin-bottom: 15px;
        font-weight: bold;
      }

      .dialog-message {
        font-size: 1.1rem;
        color: #fff;
        margin-bottom: 25px;
        line-height: 1.5;
      }

      .dialog-buttons {
        display: flex;
        gap: 15px;
        justify-content: center;
      }

      .dialog-btn {
        padding: 12px 25px;
        border: none;
        border-radius: 10px;
        font-size: 1rem;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .dialog-btn.primary {
        background: linear-gradient(45deg, #ffd700, #ffed4e);
        color: #000;
      }

      .dialog-btn.primary:hover {
        background: linear-gradient(45deg, #ffed4e, #ffd700);
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
      }

      .dialog-btn.secondary {
        background: transparent;
        color: #ffd700;
        border: 2px solid #ffd700;
      }

      .dialog-btn.secondary:hover {
        background: #ffd700;
        color: #000;
      }

      /* Animaciones de transici√≥n de preguntas */
      .question-container.transitioning {
        animation: questionTransition 1.2s ease-in-out;
      }

      @keyframes questionTransition {
        0% {
          transform: translateX(0) scale(1);
          opacity: 1;
        }
        25% {
          transform: translateX(-50px) scale(0.95);
          opacity: 0.7;
        }
        50% {
          transform: translateX(-100%) scale(0.9);
          opacity: 0;
        }
        51% {
          transform: translateX(100%) scale(0.9);
          opacity: 0;
        }
        75% {
          transform: translateX(50px) scale(0.95);
          opacity: 0.7;
        }
        100% {
          transform: translateX(0) scale(1);
          opacity: 1;
        }
      }

      .question-appear {
        animation: questionAppear 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      }

      @keyframes questionAppear {
        0% {
          transform: translateY(50px) scale(0.8);
          opacity: 0;
        }
        100% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
      }

      .option.option-reveal {
        animation: optionReveal 0.6s ease forwards;
      }

      @keyframes optionReveal {
        0% {
          transform: translateX(-30px);
          opacity: 0;
        }
        100% {
          transform: translateX(0);
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Pantalla de bienvenida -->
      <div class="welcome-screen" id="welcomeScreen">
        <h1>¬øQui√©n Quiere Ser Millonario?</h1>
        <div class="name-input">
          <input
            type="text"
            id="playerName"
            placeholder="Ingresa tu nombre"
            maxlength="20"
          />
        </div>
        <button class="start-btn" onclick="startGame()">
          ¬°Comenzar Juego!
        </button>
      </div>

      <!-- Pantalla de espera -->
      <div class="waiting-screen" id="waitingScreen">
        <div class="presenter-icon">üé§</div>
        <div class="waiting-message animated-text">
          Espera a que el presentador inicie el juego<span
            class="loading-dots"
          ></span>
        </div>
        <div style="color: #ccc; font-size: 1.1rem">
          ¬°Buena suerte,
          <span class="player-name" id="waitingPlayerName"></span>!
        </div>
      </div>

      <!-- Pantalla del juego -->
      <div class="game-screen" id="gameScreen">
        <div class="player-info">
          ¬°Bienvenido/a,
          <span class="player-name" id="playerNameDisplay"></span>!
        </div>

        <div class="question-container">
          <div class="question-number">Pregunta 1 de 15</div>
          <div class="question-text">¬øCu√°l es la capital de Francia?</div>

          <div class="options-container">
            <div
              class="option"
              onclick="selectOption(this, 'A')"
              data-option="A"
            >
              <div class="option-letter">A</div>
              <div>Madrid</div>
            </div>
            <div
              class="option"
              onclick="selectOption(this, 'B')"
              data-option="B"
            >
              <div class="option-letter">B</div>
              <div>Par√≠s</div>
            </div>
            <div
              class="option"
              onclick="selectOption(this, 'C')"
              data-option="C"
            >
              <div class="option-letter">C</div>
              <div>Londres</div>
            </div>
            <div
              class="option"
              onclick="selectOption(this, 'D')"
              data-option="D"
            >
              <div class="option-letter">D</div>
              <div>Roma</div>
            </div>
          </div>
        </div>

        <div class="lifelines">
          <div
            class="lifeline"
            onclick="useFiftyFifty()"
            id="fiftyFiftyLifeline"
          >
            50:50
          </div>
          <div
            class="lifeline"
            onclick="useAudiencePoll()"
            id="audienceLifeline"
          >
            Pregunta al P√∫blico
          </div>
        </div>
      </div>
    </div>

    <!-- Modal para pregunta al p√∫blico -->
    <div class="audience-modal" id="audienceModal">
      <div class="audience-content">
        <div class="audience-title">üé≠ Pregunta al P√∫blico üë•</div>
        <p style="text-align: center; margin-bottom: 20px; color: #ccc">
          Resultados de la votaci√≥n del p√∫blico:
        </p>
        <div class="audience-results" id="audienceResults">
          <div class="result-item">
            <div class="result-letter">A</div>
            <div class="result-bar-container">
              <div class="result-bar" id="barA"></div>
            </div>
            <div class="result-percentage" id="percentA">0%</div>
          </div>
          <div class="result-item">
            <div class="result-letter">B</div>
            <div class="result-bar-container">
              <div class="result-bar" id="barB"></div>
            </div>
            <div class="result-percentage" id="percentB">0%</div>
          </div>
          <div class="result-item">
            <div class="result-letter">C</div>
            <div class="result-bar-container">
              <div class="result-bar" id="barC"></div>
            </div>
            <div class="result-percentage" id="percentC">0%</div>
          </div>
          <div class="result-item">
            <div class="result-letter">D</div>
            <div class="result-bar-container">
              <div class="result-bar" id="barD"></div>
            </div>
            <div class="result-percentage" id="percentD">0%</div>
          </div>
        </div>
        <button class="close-audience-btn" onclick="closeAudienceModal()">
          Cerrar
        </button>
      </div>
    </div>

    <!-- Sistema de di√°logos animados -->
    <div class="dialog-overlay" id="dialogOverlay">
      <div class="dialog-box" id="dialogBox">
        <span class="dialog-icon" id="dialogIcon">‚ÑπÔ∏è</span>
        <div class="dialog-title" id="dialogTitle">T√≠tulo</div>
        <div class="dialog-message" id="dialogMessage">Mensaje</div>
        <div class="dialog-buttons" id="dialogButtons">
          <button class="dialog-btn primary" id="dialogPrimaryBtn">
            Aceptar
          </button>
        </div>
      </div>
    </div>

    <!-- Tabla de jugadores -->
    <div class="players-table" id="playersTable" style="display: none">
      <div class="players-title">JUGADORES</div>
      <div class="player-item current-player">
        <div class="player-avatar">üë§</div>
        <div class="player-info-item">
          <div class="player-name-item" id="currentPlayerName">Jugador</div>
          <div class="player-amount">$100</div>
        </div>
      </div>
      <div class="player-item">
        <div class="player-avatar">üéØ</div>
        <div class="player-info-item">
          <div class="player-name-item">Mar√≠a Garc√≠a</div>
          <div class="player-amount">$64,000</div>
        </div>
      </div>
      <div class="player-item">
        <div class="player-avatar">‚≠ê</div>
        <div class="player-info-item">
          <div class="player-name-item">Carlos L√≥pez</div>
          <div class="player-amount">$32,000</div>
        </div>
      </div>
      <div class="player-item">
        <div class="player-avatar">üî•</div>
        <div class="player-info-item">
          <div class="player-name-item">Ana Mart√≠n</div>
          <div class="player-amount">$16,000</div>
        </div>
      </div>
      <div class="player-item">
        <div class="player-avatar">üíé</div>
        <div class="player-info-item">
          <div class="player-name-item">Pedro Ruiz</div>
          <div class="player-amount">$8,000</div>
        </div>
      </div>
      <div class="player-item">
        <div class="player-avatar">üåü</div>
        <div class="player-info-item">
          <div class="player-name-item">Laura Silva</div>
          <div class="player-amount">$4,000</div>
        </div>
      </div>
      <div class="player-item">
        <div class="player-avatar">üé™</div>
        <div class="player-info-item">
          <div class="player-name-item">Diego Torres</div>
          <div class="player-amount">$2,000</div>
        </div>
      </div>
      <div class="player-item">
        <div class="player-avatar">üöÄ</div>
        <div class="player-info-item">
          <div class="player-name-item">Sofia Vega</div>
          <div class="player-amount">$1,000</div>
        </div>
      </div>
    </div>

    <!-- Escalera de premios -->
    <div class="prize-ladder" id="prizeLadder" style="display: none">
      <!-- Los premios se generar√°n din√°micamente -->
    </div>

    <script>
      // Estado del juego
      let gameState = {
        sessionId: null,
        playerName: "",
        currentQuestionId: null,
        correctAnswer: "B", // Par√≠s es la respuesta correcta
        isSpectator: false, // Flag para modo espectador
        waitingForResult: false, // Flag para indicar que estamos esperando que el admin revele el resultado
        selectedOption: null, // Opci√≥n seleccionada por el jugador
        lifelinesUsed: {
          fiftyFifty: false,
          audience: false,
        },
        questionData: {
          A: { text: "Madrid", eliminated: false },
          B: { text: "Par√≠s", eliminated: false },
          C: { text: "Londres", eliminated: false },
          D: { text: "Roma", eliminated: false },
        },
        questions: [],
        currentQuestionIndex: 0,
      };

      // Sistema de di√°logos animados
      function showDialog(options = {}) {
        const {
          icon = "‚ÑπÔ∏è",
          title = "Informaci√≥n",
          message = "",
          type = "info", // info, success, warning, error
          buttons = [{ text: "Aceptar", action: null, primary: true }],
          autoClose = false,
          duration = 3000,
        } = options;

        const overlay = document.getElementById("dialogOverlay");
        const dialogIcon = document.getElementById("dialogIcon");
        const dialogTitle = document.getElementById("dialogTitle");
        const dialogMessage = document.getElementById("dialogMessage");
        const dialogButtons = document.getElementById("dialogButtons");

        // Configurar icono seg√∫n el tipo
        const icons = {
          info: "‚ÑπÔ∏è",
          success: "‚úÖ",
          warning: "‚ö†Ô∏è",
          error: "‚ùå",
          question: "‚ùì",
          celebration: "üéâ",
        };

        dialogIcon.textContent = icon || icons[type] || icons.info;
        dialogTitle.textContent = title;
        dialogMessage.textContent = message;

        // Limpiar botones anteriores
        dialogButtons.innerHTML = "";

        // Crear botones
        buttons.forEach((button, index) => {
          const btn = document.createElement("button");
          btn.className = `dialog-btn ${
            button.primary ? "primary" : "secondary"
          }`;
          btn.textContent = button.text;
          btn.onclick = () => {
            if (button.action) button.action();
            hideDialog();
          };
          dialogButtons.appendChild(btn);
        });

        // Mostrar di√°logo
        overlay.classList.add("show");

        // Auto cerrar si se especifica
        if (autoClose) {
          setTimeout(() => {
            hideDialog();
          }, duration);
        }

        return overlay;
      }

      function hideDialog() {
        const overlay = document.getElementById("dialogOverlay");
        overlay.classList.remove("show");
      }

      // Funciones de conveniencia para diferentes tipos de di√°logo
      function showInfo(title, message, autoClose = false) {
        return showDialog({
          type: "info",
          title,
          message,
          autoClose,
          buttons: [{ text: "Entendido", primary: true }],
        });
      }

      function showSuccess(title, message, autoClose = true) {
        return showDialog({
          type: "success",
          title,
          message,
          autoClose,
          duration: 2500,
        });
      }

      function showError(title, message) {
        return showDialog({
          type: "error",
          title,
          message,
          buttons: [{ text: "Entendido", primary: true }],
        });
      }

      function showConfirm(title, message, onConfirm, onCancel = null) {
        return showDialog({
          type: "question",
          title,
          message,
          buttons: [
            { text: "Confirmar", action: onConfirm, primary: true },
            { text: "Cancelar", action: onCancel, primary: false },
          ],
        });
      }

      // Animaciones de transici√≥n de preguntas
      function animateQuestionTransition(callback) {
        const questionContainer = document.querySelector(".question-container");
        if (!questionContainer) return;

        questionContainer.classList.add("transitioning");

        setTimeout(() => {
          if (callback) callback();
          questionContainer.classList.remove("transitioning");
          questionContainer.classList.add("question-appear");

          // Animar opciones una por una
          const options = document.querySelectorAll(".option");
          options.forEach((option, index) => {
            setTimeout(() => {
              option.classList.add("option-reveal");
            }, index * 150);
          });

          setTimeout(() => {
            questionContainer.classList.remove("question-appear");
            options.forEach((option) => {
              option.classList.remove("option-reveal");
            });
          }, 1000);
        }, 600);
      }

      // Cargar nombre guardado al iniciar
      window.onload = function () {
        const savedName = localStorage.getItem("quizPlayerName");
        if (savedName) {
          document.getElementById("playerName").value = savedName;
        }

        // Conectar WebSocket del juego
        connectGameWebSocket();

        // Cargar preguntas
        loadQuestions();

        // Cargar tabla de posiciones inicial
        loadPlayersTable();

        // Verificar estado inicial del juego
        checkInitialGameState();
      };

      async function checkInitialGameState() {
        try {
          const response = await fetch("/api/game/state");
          const data = await response.json();

          if (data.success && data.data.gameState) {
            const gameState = data.data.gameState;
            if (!gameState.isActive) {
              console.log("‚è≥ El juego no est√° activo actualmente");
              // Mostrar mensaje sutil en la UI
              updateGameStatusMessage(gameState.message);
            } else {
              console.log("‚úÖ El juego est√° activo");
              updateGameStatusMessage(
                "¬°El juego est√° activo! Puedes ingresar tu nombre y jugar."
              );
            }
          }
        } catch (error) {
          console.error(
            "‚ùå Error verificando estado inicial del juego:",
            error
          );
        }
      }

      function updateGameStatusMessage(message) {
        // Crear o actualizar mensaje de estado del juego
        let statusElement = document.getElementById("gameStatusMessage");
        if (!statusElement) {
          statusElement = document.createElement("div");
          statusElement.id = "gameStatusMessage";
          statusElement.style.cssText = `
            text-align: center;
            padding: 10px 20px;
            margin: 20px auto;
            border-radius: 10px;
            font-size: 0.9rem;
            max-width: 400px;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            color: #ffd700;
          `;

          const welcomeScreen = document.getElementById("welcomeScreen");
          const nameInput = welcomeScreen.querySelector(".name-input");
          nameInput.parentNode.insertBefore(statusElement, nameInput);
        }

        statusElement.textContent = message;
      }

      async function loadQuestions() {
        try {
          console.log("üîÑ Cargando preguntas desde API...");
          const response = await fetch("/api/questions");
          const data = await response.json();

          if (data.success && data.data.questions) {
            gameState.questions = data.data.questions;
            console.log(`‚úÖ ${gameState.questions.length} preguntas cargadas`);

            // Mostrar las primeras preguntas para debug
            console.log(
              "üîç Primeras 3 preguntas:",
              gameState.questions.slice(0, 3)
            );
          } else {
            console.error("‚ùå Error cargando preguntas:", data.error);
          }
        } catch (error) {
          console.error("‚ùå Error de conexi√≥n:", error);
        }
      }

      async function loadPlayersTable() {
        try {
          const response = await fetch("/api/sessions/active");
          const data = await response.json();

          if (data.success && data.data.sessions) {
            updatePlayersTable(data.data.sessions);
            console.log(
              `‚úÖ Tabla de jugadores activos cargada con ${data.data.sessions.length} jugadores`
            );
          } else {
            console.error("‚ùå Error cargando tabla de jugadores:", data.error);
          }
        } catch (error) {
          console.error("‚ùå Error de conexi√≥n para tabla de jugadores:", error);
        }
      }

      function updatePlayersTable(activeSessions) {
        const playersTable = document.getElementById("playersTable");

        // Limpiar contenido actual excepto el t√≠tulo
        const titleElement = playersTable.querySelector(".players-title");
        playersTable.innerHTML = "";
        if (titleElement) {
          playersTable.appendChild(titleElement);
        } else {
          const newTitle = document.createElement("div");
          newTitle.className = "players-title";
          newTitle.textContent = "JUGADORES ACTIVOS";
          playersTable.appendChild(newTitle);
        }

        // Generar avatares √∫nicos para cada jugador
        const avatars = [
          "üéØ",
          "‚≠ê",
          "üî•",
          "üíé",
          "üåü",
          "üé™",
          "üöÄ",
          "üë§",
          "üé®",
          "üéµ",
          "üåä",
          "‚ö°",
          "üé≠",
          "ü¶Ñ",
          "üîÆ",
        ];

        // Agregar jugadores activos ordenados por premio actual
        const sortedSessions = activeSessions
          .filter(
            (session) =>
              session.gameStatus === "active" ||
              session.gameStatus === "eliminated"
          )
          .sort((a, b) => b.totalPrize - a.totalPrize)
          .slice(0, 8);

        sortedSessions.forEach((session, index) => {
          const playerItem = document.createElement("div");
          playerItem.className = "player-item";

          // Resaltar al jugador actual
          if (session.playerName === gameState.playerName) {
            playerItem.classList.add("current-player");
          }

          // Asignar avatar √∫nico
          const avatar = avatars[index % avatars.length];

          // Determinar estado visual del jugador
          let statusIndicator = "";
          if (session.gameStatus === "eliminated") {
            statusIndicator = "üëÅÔ∏è"; // Modo espectador
          } else if (session.gameStatus === "active") {
            statusIndicator = "üéÆ"; // Jugando activamente
          }

          playerItem.innerHTML = `
            <div class="player-avatar">${avatar}</div>
            <div class="player-info-item">
              <div class="player-name-item">${
                session.playerName
              } ${statusIndicator}</div>
              <div class="player-amount">$${session.totalPrize.toLocaleString()}</div>
            </div>
          `;

          playersTable.appendChild(playerItem);
        });

        // Si no hay jugadores activos, mostrar mensaje
        if (sortedSessions.length === 0) {
          const emptyMessage = document.createElement("div");
          emptyMessage.className = "player-item";
          emptyMessage.style.justifyContent = "center";
          emptyMessage.innerHTML =
            '<div style="color: #ccc;">No hay jugadores en la partida</div>';
          playersTable.appendChild(emptyMessage);
        }
      }

      // Configurar actualizaci√≥n peri√≥dica de la tabla de jugadores
      let playersTableInterval;
      let gameWebSocket = null;

      function connectGameWebSocket() {
        const protocol = window.location.protocol === "https:" ? "wss:" : "ws:";
        const wsUrl = `${protocol}//${window.location.host}/ws`;

        gameWebSocket = new WebSocket(wsUrl);

        gameWebSocket.onopen = function () {
          console.log("‚úÖ WebSocket del juego conectado");
        };

        gameWebSocket.onmessage = function (event) {
          try {
            const message = JSON.parse(event.data);
            handleGameWebSocketMessage(message);
          } catch (error) {
            console.error(
              "‚ùå Error procesando mensaje WebSocket del juego:",
              error
            );
          }
        };

        gameWebSocket.onclose = function () {
          console.log("üîå WebSocket del juego desconectado");
          // No reconectar autom√°ticamente durante el juego para evitar interferencias
        };

        gameWebSocket.onerror = function (error) {
          console.error("‚ùå Error WebSocket del juego:", error);
        };
      }

      function handleGameWebSocketMessage(message) {
        switch (message.type) {
          case "gameState":
            handleGameStateChange(message.data);
            break;
          case "nextQuestion":
            handleNextQuestionFromAdmin(message.data);
            break;
          case "revealAnswer":
            handleRevealAnswerFromAdmin(message.data);
            break;
          default:
            console.log(
              "üì® Mensaje WebSocket del juego no reconocido:",
              message
            );
        }

        // Actualizar tabla de jugadores cuando hay cambios de estado
        loadPlayersTable();
      }

      function handleGameStateChange(newGameState) {
        console.log("üéÆ Cambio de estado del juego:", newGameState.message);

        // Actualizar mensaje de estado en la UI
        updateGameStatusMessage(newGameState.message);

        if (newGameState.isActive) {
          // Juego iniciado por el admin
          console.log("üü¢ El juego ha sido iniciado por el administrador");
          updateGameStatusMessage(
            "¬°El juego ha sido iniciado! Ahora puedes ingresar y jugar."
          );
        } else {
          // Juego terminado por el admin
          console.log("üî¥ El juego ha sido terminado por el administrador");
          updateGameStatusMessage(
            "El juego ha sido detenido por el administrador. Todos los datos han sido limpiados."
          );

          // Si el jugador est√° en una sesi√≥n activa, mostrar mensaje y redirigir
          if (gameState.sessionId) {
            stopPlayersTableUpdates();

            // Limpiar estado local del juego
            gameState = {
              questions: [],
              currentQuestionIndex: 0,
              currentQuestionId: null,
              sessionId: null,
              playerName: null,
              isSpectator: false,
              waitingForResult: false,
              selectedOption: null,
              correctAnswer: null,
              lifelinesUsed: {
                fiftyFifty: false,
                audience: false,
                phone: false,
              },
            };

            showInfo(
              "üõë Partida Terminada",
              "La partida ha sido terminada por el administrador. Todos los datos han sido limpiados. Regresando al inicio...",
              true
            );
            setTimeout(() => {
              location.reload();
            }, 3000);
          }
        }
      }

      function handleNextQuestionFromAdmin(data) {
        console.log(
          "‚û°Ô∏è El administrador ha avanzado a la siguiente pregunta:",
          data.message
        );

        // Limpiar estado de espera de la pregunta anterior
        gameState.waitingForResult = false;
        gameState.selectedOption = null;

        // Mostrar mensaje al usuario
        showInfo(
          "‚û°Ô∏è Nueva Pregunta",
          data.message + ". Avanzando a la siguiente pregunta...",
          true
        );

        // Si el jugador est√° en el juego, avanzar autom√°ticamente
        if (gameState.sessionId && gameState.currentQuestionIndex >= 0) {
          gameState.currentQuestionIndex++;
          animateQuestionTransition(() => {
            loadCurrentQuestion();
          });
        }
      }

      function handleRevealAnswerFromAdmin(data) {
        console.log(
          "üí° El administrador ha revelado la respuesta:",
          data.message
        );

        // Si est√°bamos esperando el resultado, evaluar si la respuesta fue correcta
        if (gameState.waitingForResult && gameState.selectedOption) {
          const isCorrect =
            gameState.selectedOption === gameState.correctAnswer;

          if (isCorrect) {
            showSuccess(
              "üéâ ¬°CORRECTO!",
              `Tu respuesta "${gameState.selectedOption}" fue la correcta. La respuesta era: ${gameState.correctAnswer}`
            );

            // Si no est√° en modo espectador, avanzar a la siguiente pregunta
            if (!gameState.isSpectator) {
              setTimeout(() => {
                gameState.currentQuestionIndex++;
                loadCurrentQuestion();
              }, 3000);
            }
          } else {
            showError(
              "‚ùå INCORRECTO",
              `Tu respuesta "${gameState.selectedOption}" no fue correcta. La respuesta correcta era: ${gameState.correctAnswer}`
            );
          }

          // Limpiar estado de espera
          gameState.waitingForResult = false;
          gameState.selectedOption = null;
        } else {
          // Solo mostrar el mensaje del admin si no est√°bamos esperando resultado
          showInfo("üí° Respuesta Revelada", data.message, true);
        }

        // Si estamos en una pregunta activa, resaltar la respuesta correcta
        if (gameState.correctAnswer) {
          const options = document.querySelectorAll(".option");
          options.forEach((option) => {
            const optionLetter = option.getAttribute("data-option");
            if (optionLetter === gameState.correctAnswer) {
              option.style.background =
                "linear-gradient(45deg, #4caf50, #45a049)";
              option.style.color = "white";
              option.style.fontWeight = "bold";
            }
          });

          // Si no est√°bamos esperando resultado, mostrar mensaje espec√≠fico con la respuesta
          if (!gameState.waitingForResult) {
            setTimeout(() => {
              showInfo(
                "üí° Respuesta Correcta",
                `La respuesta correcta es: ${gameState.correctAnswer}`,
                true
              );
            }, 1000);
          }
        }

        // Rehabilitar las opciones para la siguiente pregunta (si no est√° en modo espectador)
        if (!gameState.isSpectator) {
          setTimeout(() => {
            const allOptions = document.querySelectorAll(".option");
            allOptions.forEach((opt) => {
              opt.style.pointerEvents = "auto";
              opt.style.opacity = "1";
            });
          }, 2000);
        }
      }

      function enterSpectatorMode() {
        console.log("üëÅÔ∏è Entrando en modo espectador...");

        // Mostrar mensaje al usuario
        showInfo(
          "üëÅÔ∏è Modo Espectador",
          "Ahora est√°s en modo espectador. Podr√°s ver las preguntas y respuestas correctas pero no podr√°s participar.",
          true
        );

        // Marcar como espectador
        gameState.isSpectator = true;

        // Deshabilitar todas las opciones de respuesta
        const options = document.querySelectorAll(".option");
        options.forEach((option) => {
          option.style.opacity = "0.5";
          option.style.pointerEvents = "none";
          option.style.cursor = "not-allowed";
        });

        // Deshabilitar botones de comodines
        const lifelineButtons = document.querySelectorAll(".lifeline-btn");
        lifelineButtons.forEach((btn) => {
          btn.disabled = true;
          btn.style.opacity = "0.5";
          btn.style.cursor = "not-allowed";
        });

        // Agregar mensaje de espectador en la interfaz
        const questionArea = document.querySelector(".question-area");
        if (questionArea) {
          let spectatorMessage = document.getElementById("spectatorMessage");
          if (!spectatorMessage) {
            spectatorMessage = document.createElement("div");
            spectatorMessage.id = "spectatorMessage";
            spectatorMessage.style.cssText = `
              background: rgba(255, 165, 0, 0.1);
              border: 2px solid #ffa500;
              border-radius: 10px;
              padding: 10px 15px;
              margin: 10px 0;
              text-align: center;
              color: #ffa500;
              font-weight: bold;
              font-size: 0.9rem;
            `;
            spectatorMessage.textContent =
              "üëÅÔ∏è MODO ESPECTADOR - Solo puedes observar";
            questionArea.insertBefore(
              spectatorMessage,
              questionArea.firstChild
            );
          }
        }

        // Continuar viendo el juego pero sin poder participar
        // El jugador seguir√° recibiendo actualizaciones de preguntas por WebSocket
        console.log("‚úÖ Modo espectador activado");
      }

      async function startPlayersTableUpdates() {
        // Actualizar cada 10 segundos
        playersTableInterval = setInterval(loadPlayersTable, 10000);
      }

      function stopPlayersTableUpdates() {
        if (playersTableInterval) {
          clearInterval(playersTableInterval);
          playersTableInterval = null;
        }
      }

      async function startGame() {
        const playerName = document.getElementById("playerName").value.trim();

        if (playerName === "") {
          showError("‚ùå Error", "Por favor, ingresa tu nombre para comenzar");
          return;
        }

        // Guardar nombre en localStorage
        localStorage.setItem("quizPlayerName", playerName);
        gameState.playerName = playerName;

        try {
          // üîç VERIFICAR ESTADO DEL JUEGO ANTES DE CREAR SESI√ìN
          const gameStateResponse = await fetch("/api/game/state");
          const gameStateData = await gameStateResponse.json();

          if (
            !gameStateData.success ||
            !gameStateData.data.gameState.isActive
          ) {
            showInfo(
              "‚è≥ Juego Inactivo",
              "El juego no est√° activo. Espera a que el administrador inicie la partida."
            );
            return;
          }

          // Crear o recuperar sesi√≥n
          const response = await fetch("/api/sessions", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              playerName: playerName,
            }),
          });

          const data = await response.json();

          if (data.success && data.data.session) {
            gameState.sessionId = data.data.session.id;

            // Cargar estado de la sesi√≥n
            loadSessionState(data.data.session);

            console.log(`‚úÖ Sesi√≥n creada/recuperada: ${gameState.sessionId}`);

            // Proceder con el juego
            proceedToGame(playerName);
          } else {
            console.error("‚ùå Error creando sesi√≥n:", data.error);
            showError(
              "‚ùå Error",
              `${data.error || "Error creando sesi√≥n. Int√©ntalo de nuevo."}`
            );
            return;
          }
        } catch (error) {
          console.error("‚ùå Error de conexi√≥n:", error);
          showError(
            "‚ùå Error de Conexi√≥n",
            "Error de conexi√≥n. Verifica tu internet y que el servidor est√© funcionando."
          );
          return;
        }
      }

      function proceedToGame(playerName) {
        // Ocultar pantalla de bienvenida
        document.getElementById("welcomeScreen").style.display = "none";

        // Mostrar pantalla de espera
        document.getElementById("waitingScreen").style.display = "block";
        document.getElementById("waitingPlayerName").textContent = playerName;

        // Iniciar actualizaciones de tabla de posiciones
        startPlayersTableUpdates();

        // Esperar 2 segundos y luego mostrar el juego
        setTimeout(async () => {
          // Ocultar pantalla de espera
          document.getElementById("waitingScreen").style.display = "none";

          // Mostrar pantalla del juego
          document.getElementById("gameScreen").style.display = "block";
          document.getElementById("prizeLadder").style.display = "block";
          document.getElementById("playersTable").style.display = "block";

          // Inicializar escalera de premios
          updatePrizeLadder();

          // Mostrar nombre del jugador
          const playerNameDisplay =
            document.getElementById("playerNameDisplay");
          const currentPlayerName =
            document.getElementById("currentPlayerName");

          if (playerNameDisplay) {
            playerNameDisplay.textContent = playerName;
          }
          if (currentPlayerName) {
            currentPlayerName.textContent = playerName;
          }

          // üîç ASEGURAR QUE LAS PREGUNTAS EST√âN CARGADAS ANTES DE CONTINUAR
          if (!gameState.questions || gameState.questions.length === 0) {
            console.log("‚è≥ Cargando preguntas antes de comenzar...");
            await loadQuestions();
          }

          if (!gameState.questions || gameState.questions.length === 0) {
            showError(
              "‚ùå Error",
              "No se pudieron cargar las preguntas. Recarga la p√°gina."
            );
            return;
          }

          // Cargar primera pregunta
          loadCurrentQuestion();
        }, 2000);
      }

      function loadSessionState(session) {
        // Cargar comodines usados
        gameState.lifelinesUsed = {
          fiftyFifty: session.lifelinesUsed.fiftyFifty,
          audience: session.lifelinesUsed.audience,
        };

        // Actualizar UI de comodines
        if (gameState.lifelinesUsed.fiftyFifty) {
          document.getElementById("fiftyFiftyLifeline").classList.add("used");
        }
        if (gameState.lifelinesUsed.audience) {
          document.getElementById("audienceLifeline").classList.add("used");
        }

        // Cargar pregunta actual
        gameState.currentQuestionIndex = session.currentQuestion - 1;

        console.log(
          `üìä Estado cargado: Pregunta ${session.currentQuestion}, Premio: $${session.totalPrize}`
        );
      }

      async function loadCurrentQuestion() {
        // üîç VALIDAR QUE TENGAMOS PREGUNTAS CARGADAS
        if (!gameState.questions || gameState.questions.length === 0) {
          console.log("‚è≥ Esperando a que se carguen las preguntas...");
          try {
            await loadQuestions();
            if (!gameState.questions || gameState.questions.length === 0) {
              showError(
                "‚ùå Error",
                "No se pudieron cargar las preguntas. Verifica la conexi√≥n al servidor."
              );
              return;
            }
          } catch (error) {
            console.error("‚ùå Error cargando preguntas:", error);
            showError(
              "‚ùå Error",
              "Error cargando preguntas. Recarga la p√°gina."
            );
            return;
          }
        }

        if (gameState.currentQuestionIndex >= gameState.questions.length) {
          showSuccess(
            "üéâ ¬°Felicidades!",
            "Has completado todas las preguntas disponibles."
          );
          return;
        }

        const question = gameState.questions[gameState.currentQuestionIndex];

        // üîç VALIDAR QUE LA PREGUNTA EXISTE
        if (!question) {
          console.error(
            `‚ùå Pregunta no encontrada en √≠ndice ${gameState.currentQuestionIndex}`
          );
          showError("‚ùå Error", "Error cargando la pregunta. Reintentando...");

          // Reintentar cargar preguntas
          try {
            await loadQuestions();
            if (gameState.questions[gameState.currentQuestionIndex]) {
              loadCurrentQuestion(); // Recursivo
              return;
            }
          } catch (error) {
            console.error("‚ùå Error en reintento:", error);
          }

          showError(
            "‚ùå Error",
            "No se pudo cargar la pregunta. Recarga la p√°gina."
          );
          return;
        }

        // üîç VALIDAR QUE LA PREGUNTA TIENE UN ID V√ÅLIDO
        if (!question.id || question.id <= 0) {
          console.error(`‚ùå Pregunta sin ID v√°lido:`, question);
          showError("‚ùå Error", "Pregunta sin ID v√°lido. Recarga la p√°gina.");
          return;
        }

        gameState.currentQuestionId = question.id;
        gameState.correctAnswer = question.correctAnswer;

        console.log(
          `üéØ Pregunta cargada - ID: ${question.id}, √çndice: ${gameState.currentQuestionIndex}`
        );
        console.log(`üîç Pregunta completa:`, question);

        // Actualizar UI
        document.querySelector(".question-number").textContent = `Pregunta ${
          gameState.currentQuestionIndex + 1
        } de ${gameState.questions.length}`;
        document.querySelector(".question-text").textContent =
          question.question;

        // Cargar opciones
        const options = document.querySelectorAll(".option");
        const letters = ["A", "B", "C", "D"];

        options.forEach((option, index) => {
          const letter = letters[index];
          option.setAttribute("data-option", letter);

          // üîç VALIDAR QUE LAS OPCIONES EXISTEN
          const optionText =
            question.options && question.options[letter]
              ? question.options[letter]
              : `Opci√≥n ${letter}`;

          option.querySelector("div:last-child").textContent = optionText;

          // Resetear estado
          option.classList.remove("eliminated");
          option.style.background =
            "linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)";
          option.style.borderColor = "#4a4a4a";
          option.style.color = "white";

          // Rehabilitar opciones para nueva pregunta (si no est√° en modo espectador)
          if (!gameState.isSpectator) {
            option.style.pointerEvents = "auto";
            option.style.opacity = "1";
          }

          // Actualizar gameState
          gameState.questionData[letter] = {
            text: optionText,
            eliminated: false,
          };
        });

        console.log(
          `‚úÖ Pregunta ${gameState.currentQuestionIndex + 1} cargada: ${
            question.question
          }`
        );

        // Actualizar escalera de premios
        updatePrizeLadder();
      }

      function updatePrizeLadder() {
        const prizeLadder = document.getElementById("prizeLadder");
        if (!prizeLadder) return;

        // Definir los premios en orden ascendente (de menor a mayor)
        const prizeAmounts = [
          100, 200, 300, 500, 1000, 2000, 4000, 8000, 16000, 32000, 64000,
          125000, 250000, 500000, 1000000,
        ];

        // Limpiar escalera actual
        prizeLadder.innerHTML = "";

        // Crear elementos de premio en orden descendente (m√°s alto primero)
        prizeAmounts
          .slice()
          .reverse()
          .forEach((amount, index) => {
            const prizeItem = document.createElement("div");
            prizeItem.className = "prize-item";

            // El √≠ndice real de la pregunta (0-based) vs display (1-based)
            const questionNumber = gameState.currentQuestionIndex + 1;
            const prizeIndex = prizeAmounts.length - index; // 15, 14, 13... 1

            // Marcar como actual si corresponde a la pregunta actual
            if (prizeIndex === questionNumber) {
              prizeItem.classList.add("current");
            }

            // Marcar como ganado si est√° por debajo de la pregunta actual
            if (prizeIndex < questionNumber) {
              prizeItem.classList.add("won");
            }

            prizeItem.textContent = `$${amount.toLocaleString()}`;
            prizeLadder.appendChild(prizeItem);
          });

        console.log(
          `üéØ Escalera de premios actualizada para pregunta ${
            gameState.currentQuestionIndex + 1
          }`
        );
      }

      async function useFiftyFifty() {
        // Verificar si est√° en modo espectador
        if (gameState.isSpectator) {
          showInfo(
            "üëÅÔ∏è Modo Espectador",
            "Est√°s en modo espectador. No puedes usar comodines."
          );
          return;
        }

        // Verificar si ya se us√≥ este comod√≠n
        if (gameState.lifelinesUsed.fiftyFifty) {
          showInfo("‚ö†Ô∏è Comod√≠n Usado", "Ya has usado este comod√≠n");
          return;
        }

        try {
          // Marcar comod√≠n como usado en el backend
          const response = await fetch(
            `/api/sessions/${gameState.sessionId}/lifeline`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                type: "fiftyFifty",
              }),
            }
          );

          const data = await response.json();

          if (!data.success) {
            showError("‚ùå Error", data.error || "Error usando comod√≠n");
            return;
          }

          console.log("‚úÖ Comod√≠n 50:50 registrado en el backend");
        } catch (error) {
          console.error("‚ùå Error registrando comod√≠n:", error);
        }

        // Marcar el comod√≠n como usado localmente
        gameState.lifelinesUsed.fiftyFifty = true;
        const lifeline = document.getElementById("fiftyFiftyLifeline");
        lifeline.classList.add("used");

        // Obtener todas las opciones
        const options = document.querySelectorAll(".option");
        const incorrectOptions = [];

        // Encontrar opciones incorrectas
        options.forEach((option) => {
          const optionLetter = option.getAttribute("data-option");
          if (optionLetter !== gameState.correctAnswer) {
            incorrectOptions.push(option);
          }
        });

        // Seleccionar aleatoriamente 2 opciones incorrectas para eliminar
        const optionsToEliminate = [];
        const shuffledIncorrect = incorrectOptions.sort(
          () => 0.5 - Math.random()
        );
        optionsToEliminate.push(shuffledIncorrect[0], shuffledIncorrect[1]);

        // Marcar opciones como eliminadas en el estado del juego
        optionsToEliminate.forEach((option) => {
          const letter = option.getAttribute("data-option");
          gameState.questionData[letter].eliminated = true;
        });

        // Animar la eliminaci√≥n con delay
        optionsToEliminate.forEach((option, index) => {
          setTimeout(() => {
            // Efecto de highlight antes de eliminar
            option.style.animation = "highlight 0.5s ease-in-out";

            setTimeout(() => {
              option.classList.add("eliminated");

              // Sonido de eliminaci√≥n (simulado con vibraci√≥n en m√≥viles)
              if (navigator.vibrate) {
                navigator.vibrate(100);
              }
            }, 500);
          }, index * 300);
        });

        // Mostrar mensaje despu√©s de la animaci√≥n
        setTimeout(() => {
          showSuccess(
            "50:50 Usado!",
            "Dos opciones incorrectas han sido eliminadas."
          );
        }, 1500);
      }

      async function useAudiencePoll() {
        // Verificar si est√° en modo espectador
        if (gameState.isSpectator) {
          showInfo(
            "üëÅÔ∏è Modo Espectador",
            "Est√°s en modo espectador. No puedes usar comodines."
          );
          return;
        }

        // Verificar si ya se us√≥ este comod√≠n
        if (gameState.lifelinesUsed.audience) {
          showInfo("‚ö†Ô∏è Comod√≠n Usado", "Ya has usado este comod√≠n");
          return;
        }

        try {
          // Marcar comod√≠n como usado en el backend
          const response = await fetch(
            `/api/sessions/${gameState.sessionId}/lifeline`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                type: "audience",
              }),
            }
          );

          const data = await response.json();

          if (!data.success) {
            showError("‚ùå Error", data.error || "Error usando comod√≠n");
            return;
          }

          console.log(
            "‚úÖ Comod√≠n pregunta al p√∫blico registrado en el backend"
          );
        } catch (error) {
          console.error("‚ùå Error registrando comod√≠n:", error);
        }

        // Marcar el comod√≠n como usado localmente
        gameState.lifelinesUsed.audience = true;
        const lifeline = document.getElementById("audienceLifeline");
        lifeline.classList.add("used");

        // Mostrar modal
        document.getElementById("audienceModal").classList.add("show");

        // Generar porcentajes simulados
        const percentages = generateAudiencePercentages();

        // Animar las barras con delay
        setTimeout(() => {
          animateAudienceBars(percentages);
        }, 300);
      }

      function generateAudiencePercentages() {
        const availableOptions = [];

        // Solo incluir opciones no eliminadas
        Object.keys(gameState.questionData).forEach((letter) => {
          if (!gameState.questionData[letter].eliminated) {
            availableOptions.push(letter);
          }
        });

        const percentages = { A: 0, B: 0, C: 0, D: 0 };

        if (availableOptions.length === 0) return percentages;

        // Dar mayor probabilidad a la respuesta correcta
        let remaining = 100;

        if (availableOptions.includes(gameState.correctAnswer)) {
          // La respuesta correcta tiene entre 45-75% de probabilidad
          percentages[gameState.correctAnswer] =
            Math.floor(Math.random() * 31) + 45; // 45-75%
          remaining -= percentages[gameState.correctAnswer];
        }

        // Distribuir el resto entre las opciones disponibles (excluyendo la correcta)
        const otherOptions = availableOptions.filter(
          (letter) => letter !== gameState.correctAnswer
        );

        otherOptions.forEach((letter, index) => {
          if (index === otherOptions.length - 1) {
            // La √∫ltima opci√≥n obtiene lo que queda
            percentages[letter] = remaining;
          } else {
            // Distribuir aleatoriamente parte del resto
            const maxForThis = Math.floor(
              remaining / (otherOptions.length - index)
            );
            const randomPercent = Math.floor(Math.random() * maxForThis);
            percentages[letter] = randomPercent;
            remaining -= randomPercent;
          }
        });

        return percentages;
      }

      function animateAudienceBars(percentages) {
        Object.keys(percentages).forEach((letter, index) => {
          setTimeout(() => {
            const bar = document.getElementById(`bar${letter}`);
            const percentElement = document.getElementById(`percent${letter}`);

            // Animar el porcentaje
            animatePercentage(percentElement, percentages[letter]);

            // Animar la barra
            bar.style.width = percentages[letter] + "%";

            // Vibraci√≥n en m√≥viles
            if (navigator.vibrate) {
              navigator.vibrate(50);
            }
          }, index * 200);
        });
      }

      function animatePercentage(element, targetPercent) {
        let current = 0;
        const increment = targetPercent / 30; // 30 frames de animaci√≥n

        const animation = setInterval(() => {
          current += increment;
          if (current >= targetPercent) {
            current = targetPercent;
            clearInterval(animation);
          }
          element.textContent = Math.floor(current) + "%";
        }, 50);
      }

      function closeAudienceModal() {
        document.getElementById("audienceModal").classList.remove("show");
      }

      async function selectOption(option, optionLetter) {
        // Verificar si est√° en modo espectador
        if (gameState.isSpectator) {
          showInfo(
            "üëÅÔ∏è Modo Espectador",
            "Est√°s en modo espectador. No puedes seleccionar respuestas."
          );
          return;
        }

        // Verificar si la opci√≥n est√° eliminada
        if (option.classList.contains("eliminated")) {
          return;
        }

        // Remover selecci√≥n previa
        const allOptions = document.querySelectorAll(".option");
        allOptions.forEach((opt) => {
          if (!opt.classList.contains("eliminated")) {
            opt.style.background =
              "linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)";
            opt.style.borderColor = "#4a4a4a";
            opt.style.color = "white";
          }
        });

        // Marcar opci√≥n seleccionada
        option.style.background =
          "linear-gradient(135deg, #ffd700 0%, #ffed4e 100%)";
        option.style.borderColor = "#ffd700";
        option.style.color = "#000";

        // Enviar respuesta al backend
        try {
          // üîç VALIDAR QUE TENEMOS UN ID DE PREGUNTA V√ÅLIDO
          if (
            !gameState.currentQuestionId ||
            gameState.currentQuestionId <= 0
          ) {
            console.error(
              "‚ùå Error: No hay ID de pregunta v√°lido",
              gameState.currentQuestionId
            );
            console.error("üîç Estado completo del juego:", gameState);
            showError(
              "‚ùå Error",
              "No se puede enviar la respuesta. ID de pregunta inv√°lido."
            );
            return;
          }

          console.log(
            `üì§ Enviando respuesta - Pregunta ID: ${gameState.currentQuestionId}, Opci√≥n: ${optionLetter}`
          );
          console.log(`üîç Estado actual:`, {
            currentQuestionId: gameState.currentQuestionId,
            currentQuestionIndex: gameState.currentQuestionIndex,
            totalQuestions: gameState.questions
              ? gameState.questions.length
              : 0,
            sessionId: gameState.sessionId,
          });

          const startTime = Date.now();
          const response = await fetch(
            `/api/sessions/${gameState.sessionId}/answer`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                questionId: gameState.currentQuestionId,
                selectedOption: optionLetter,
                timeToAnswer: Math.floor((Date.now() - startTime) / 1000),
              }),
            }
          );

          const data = await response.json();

          if (data.success) {
            const session = data.data.session;

            // Solo confirmar que la respuesta fue enviada, no mostrar el resultado
            setTimeout(() => {
              // Simplemente confirmar el env√≠o
              showSuccess(
                "‚úÖ Respuesta Enviada",
                "Tu respuesta ha sido enviada. Espera a que el administrador revele el resultado."
              );

              // Deshabilitar todas las opciones para evitar cambios
              const allOptions = document.querySelectorAll(".option");
              allOptions.forEach((opt) => {
                opt.style.pointerEvents = "none";
                opt.style.opacity = "0.7";
              });

              // Marcar que estamos esperando el resultado
              gameState.waitingForResult = true;
              gameState.selectedOption = optionLetter;

              // Si el jugador fue eliminado, entrar en modo espectador despu√©s de un tiempo
              if (session.gameStatus === "eliminated") {
                setTimeout(() => {
                  enterSpectatorMode();
                }, 1000);
              }
            }, 500);
          } else {
            showError("‚ùå Error", "Error enviando respuesta: " + data.error);
          }
        } catch (error) {
          console.error("‚ùå Error enviando respuesta:", error);
          showError(
            "‚ùå Error de Conexi√≥n",
            "Error de conexi√≥n al enviar respuesta"
          );
        }
      }

      // Permitir presionar Enter para comenzar el juego
      document
        .getElementById("playerName")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            startGame();
          }
        });
    </script>
  </body>
</html>
